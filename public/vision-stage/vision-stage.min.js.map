{"version":3,"file":"vision-stage.min.js","sources":["../../node_modules/lit-html/lib/directive.js","../../node_modules/lit-html/lib/dom.js","../../node_modules/lit-html/lib/part.js","../../node_modules/lit-html/lib/template.js","../../node_modules/lit-html/lib/template-instance.js","../../node_modules/lit-html/lib/template-result.js","../../node_modules/lit-html/lib/parts.js","../../node_modules/lit-html/lib/default-template-processor.js","../../node_modules/lit-html/lib/template-factory.js","../../node_modules/lit-html/lib/render.js","../../node_modules/lit-html/lit-html.js","../../node_modules/lit-html/directives/unsafe-html.js","../../node_modules/lit-html/directives/if-defined.js","../../node_modules/lit-html/directives/repeat.js","../../node_modules/lit-html/directives/live.js","../../node_modules/lit-html/directives/guard.js","../../node_modules/lit-html/directives/cache.js","../../src/utils-core.js","../../src/vision-stage.beta-a.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nconst directives = new WeakMap();\n/**\n * Brands a function as a directive factory function so that lit-html will call\n * the function during template rendering, rather than passing as a value.\n *\n * A _directive_ is a function that takes a Part as an argument. It has the\n * signature: `(part: Part) => void`.\n *\n * A directive _factory_ is a function that takes arguments for data and\n * configuration and returns a directive. Users of directive usually refer to\n * the directive factory as the directive. For example, \"The repeat directive\".\n *\n * Usually a template author will invoke a directive factory in their template\n * with relevant arguments, which will then return a directive function.\n *\n * Here's an example of using the `repeat()` directive factory that takes an\n * array and a function to render an item:\n *\n * ```js\n * html`<ul><${repeat(items, (item) => html`<li>${item}</li>`)}</ul>`\n * ```\n *\n * When `repeat` is invoked, it returns a directive function that closes over\n * `items` and the template function. When the outer template is rendered, the\n * return directive function is called with the Part for the expression.\n * `repeat` then performs it's custom logic to render multiple items.\n *\n * @param f The directive factory function. Must be a function that returns a\n * function of the signature `(part: Part) => void`. The returned function will\n * be called with the part object.\n *\n * @example\n *\n * import {directive, html} from 'lit-html';\n *\n * const immutable = directive((v) => (part) => {\n *   if (part.value !== v) {\n *     part.setValue(v)\n *   }\n * });\n */\nexport const directive = (f) => ((...args) => {\n    const d = f(...args);\n    directives.set(d, true);\n    return d;\n});\nexport const isDirective = (o) => {\n    return typeof o === 'function' && directives.has(o);\n};\n//# sourceMappingURL=directive.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * True if the custom elements polyfill is in use.\n */\nexport const isCEPolyfill = typeof window !== 'undefined' &&\n    window.customElements != null &&\n    window.customElements.polyfillWrapFlushCallback !==\n        undefined;\n/**\n * Reparents nodes, starting from `start` (inclusive) to `end` (exclusive),\n * into another container (could be the same container), before `before`. If\n * `before` is null, it appends the nodes to the container.\n */\nexport const reparentNodes = (container, start, end = null, before = null) => {\n    while (start !== end) {\n        const n = start.nextSibling;\n        container.insertBefore(start, before);\n        start = n;\n    }\n};\n/**\n * Removes nodes, starting from `start` (inclusive) to `end` (exclusive), from\n * `container`.\n */\nexport const removeNodes = (container, start, end = null) => {\n    while (start !== end) {\n        const n = start.nextSibling;\n        container.removeChild(start);\n        start = n;\n    }\n};\n//# sourceMappingURL=dom.js.map","/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nexport const noChange = {};\n/**\n * A sentinel value that signals a NodePart to fully clear its content.\n */\nexport const nothing = {};\n//# sourceMappingURL=part.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * An expression marker with embedded unique key to avoid collision with\n * possible text in templates.\n */\nexport const marker = `{{lit-${String(Math.random()).slice(2)}}}`;\n/**\n * An expression marker used text-positions, multi-binding attributes, and\n * attributes with markup-like text values.\n */\nexport const nodeMarker = `<!--${marker}-->`;\nexport const markerRegex = new RegExp(`${marker}|${nodeMarker}`);\n/**\n * Suffix appended to all bound attribute names.\n */\nexport const boundAttributeSuffix = '$lit$';\n/**\n * An updatable Template that tracks the location of dynamic parts.\n */\nexport class Template {\n    constructor(result, element) {\n        this.parts = [];\n        this.element = element;\n        const nodesToRemove = [];\n        const stack = [];\n        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n        const walker = document.createTreeWalker(element.content, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);\n        // Keeps track of the last index associated with a part. We try to delete\n        // unnecessary nodes, but we never want to associate two different parts\n        // to the same index. They must have a constant node between.\n        let lastPartIndex = 0;\n        let index = -1;\n        let partIndex = 0;\n        const { strings, values: { length } } = result;\n        while (partIndex < length) {\n            const node = walker.nextNode();\n            if (node === null) {\n                // We've exhausted the content inside a nested template element.\n                // Because we still have parts (the outer for-loop), we know:\n                // - There is a template in the stack\n                // - The walker will find a nextNode outside the template\n                walker.currentNode = stack.pop();\n                continue;\n            }\n            index++;\n            if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n                if (node.hasAttributes()) {\n                    const attributes = node.attributes;\n                    const { length } = attributes;\n                    // Per\n                    // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,\n                    // attributes are not guaranteed to be returned in document order.\n                    // In particular, Edge/IE can return them out of order, so we cannot\n                    // assume a correspondence between part index and attribute index.\n                    let count = 0;\n                    for (let i = 0; i < length; i++) {\n                        if (endsWith(attributes[i].name, boundAttributeSuffix)) {\n                            count++;\n                        }\n                    }\n                    while (count-- > 0) {\n                        // Get the template literal section leading up to the first\n                        // expression in this attribute\n                        const stringForPart = strings[partIndex];\n                        // Find the attribute name\n                        const name = lastAttributeNameRegex.exec(stringForPart)[2];\n                        // Find the corresponding attribute\n                        // All bound attributes have had a suffix added in\n                        // TemplateResult#getHTML to opt out of special attribute\n                        // handling. To look up the attribute value we also need to add\n                        // the suffix.\n                        const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;\n                        const attributeValue = node.getAttribute(attributeLookupName);\n                        node.removeAttribute(attributeLookupName);\n                        const statics = attributeValue.split(markerRegex);\n                        this.parts.push({ type: 'attribute', index, name, strings: statics });\n                        partIndex += statics.length - 1;\n                    }\n                }\n                if (node.tagName === 'TEMPLATE') {\n                    stack.push(node);\n                    walker.currentNode = node.content;\n                }\n            }\n            else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n                const data = node.data;\n                if (data.indexOf(marker) >= 0) {\n                    const parent = node.parentNode;\n                    const strings = data.split(markerRegex);\n                    const lastIndex = strings.length - 1;\n                    // Generate a new text node for each literal section\n                    // These nodes are also used as the markers for node parts\n                    for (let i = 0; i < lastIndex; i++) {\n                        let insert;\n                        let s = strings[i];\n                        if (s === '') {\n                            insert = createMarker();\n                        }\n                        else {\n                            const match = lastAttributeNameRegex.exec(s);\n                            if (match !== null && endsWith(match[2], boundAttributeSuffix)) {\n                                s = s.slice(0, match.index) + match[1] +\n                                    match[2].slice(0, -boundAttributeSuffix.length) + match[3];\n                            }\n                            insert = document.createTextNode(s);\n                        }\n                        parent.insertBefore(insert, node);\n                        this.parts.push({ type: 'node', index: ++index });\n                    }\n                    // If there's no text, we must insert a comment to mark our place.\n                    // Else, we can trust it will stick around after cloning.\n                    if (strings[lastIndex] === '') {\n                        parent.insertBefore(createMarker(), node);\n                        nodesToRemove.push(node);\n                    }\n                    else {\n                        node.data = strings[lastIndex];\n                    }\n                    // We have a part for each match found\n                    partIndex += lastIndex;\n                }\n            }\n            else if (node.nodeType === 8 /* Node.COMMENT_NODE */) {\n                if (node.data === marker) {\n                    const parent = node.parentNode;\n                    // Add a new marker node to be the startNode of the Part if any of\n                    // the following are true:\n                    //  * We don't have a previousSibling\n                    //  * The previousSibling is already the start of a previous part\n                    if (node.previousSibling === null || index === lastPartIndex) {\n                        index++;\n                        parent.insertBefore(createMarker(), node);\n                    }\n                    lastPartIndex = index;\n                    this.parts.push({ type: 'node', index });\n                    // If we don't have a nextSibling, keep this node so we have an end.\n                    // Else, we can remove it to save future costs.\n                    if (node.nextSibling === null) {\n                        node.data = '';\n                    }\n                    else {\n                        nodesToRemove.push(node);\n                        index--;\n                    }\n                    partIndex++;\n                }\n                else {\n                    let i = -1;\n                    while ((i = node.data.indexOf(marker, i + 1)) !== -1) {\n                        // Comment node has a binding marker inside, make an inactive part\n                        // The binding won't work, but subsequent bindings will\n                        // TODO (justinfagnani): consider whether it's even worth it to\n                        // make bindings in comments work\n                        this.parts.push({ type: 'node', index: -1 });\n                        partIndex++;\n                    }\n                }\n            }\n        }\n        // Remove text binding nodes after the walk to not disturb the TreeWalker\n        for (const n of nodesToRemove) {\n            n.parentNode.removeChild(n);\n        }\n    }\n}\nconst endsWith = (str, suffix) => {\n    const index = str.length - suffix.length;\n    return index >= 0 && str.slice(index) === suffix;\n};\nexport const isTemplatePartActive = (part) => part.index !== -1;\n// Allows `document.createComment('')` to be renamed for a\n// small manual size-savings.\nexport const createMarker = () => document.createComment('');\n/**\n * This regex extracts the attribute name preceding an attribute-position\n * expression. It does this by matching the syntax allowed for attributes\n * against the string literal directly preceding the expression, assuming that\n * the expression is in an attribute-value position.\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\n *\n * \" \\x09\\x0a\\x0c\\x0d\" are HTML space characters:\n * https://www.w3.org/TR/html5/infrastructure.html#space-characters\n *\n * \"\\0-\\x1F\\x7F-\\x9F\" are Unicode control characters, which includes every\n * space character except \" \".\n *\n * So an attribute is:\n *  * The name: any character except a control character, space character, ('),\n *    (\"), \">\", \"=\", or \"/\"\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nexport const lastAttributeNameRegex = \n// eslint-disable-next-line no-control-regex\n/([ \\x09\\x0a\\x0c\\x0d])([^\\0-\\x1F\\x7F-\\x9F \"'>=/]+)([ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*))$/;\n//# sourceMappingURL=template.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { isCEPolyfill } from './dom.js';\nimport { isTemplatePartActive } from './template.js';\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nexport class TemplateInstance {\n    constructor(template, processor, options) {\n        this.__parts = [];\n        this.template = template;\n        this.processor = processor;\n        this.options = options;\n    }\n    update(values) {\n        let i = 0;\n        for (const part of this.__parts) {\n            if (part !== undefined) {\n                part.setValue(values[i]);\n            }\n            i++;\n        }\n        for (const part of this.__parts) {\n            if (part !== undefined) {\n                part.commit();\n            }\n        }\n    }\n    _clone() {\n        // There are a number of steps in the lifecycle of a template instance's\n        // DOM fragment:\n        //  1. Clone - create the instance fragment\n        //  2. Adopt - adopt into the main document\n        //  3. Process - find part markers and create parts\n        //  4. Upgrade - upgrade custom elements\n        //  5. Update - set node, attribute, property, etc., values\n        //  6. Connect - connect to the document. Optional and outside of this\n        //     method.\n        //\n        // We have a few constraints on the ordering of these steps:\n        //  * We need to upgrade before updating, so that property values will pass\n        //    through any property setters.\n        //  * We would like to process before upgrading so that we're sure that the\n        //    cloned fragment is inert and not disturbed by self-modifying DOM.\n        //  * We want custom elements to upgrade even in disconnected fragments.\n        //\n        // Given these constraints, with full custom elements support we would\n        // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect\n        //\n        // But Safari does not implement CustomElementRegistry#upgrade, so we\n        // can not implement that order and still have upgrade-before-update and\n        // upgrade disconnected fragments. So we instead sacrifice the\n        // process-before-upgrade constraint, since in Custom Elements v1 elements\n        // must not modify their light DOM in the constructor. We still have issues\n        // when co-existing with CEv0 elements like Polymer 1, and with polyfills\n        // that don't strictly adhere to the no-modification rule because shadow\n        // DOM, which may be created in the constructor, is emulated by being placed\n        // in the light DOM.\n        //\n        // The resulting order is on native is: Clone, Adopt, Upgrade, Process,\n        // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade\n        // in one step.\n        //\n        // The Custom Elements v1 polyfill supports upgrade(), so the order when\n        // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,\n        // Connect.\n        const fragment = isCEPolyfill ?\n            this.template.element.content.cloneNode(true) :\n            document.importNode(this.template.element.content, true);\n        const stack = [];\n        const parts = this.template.parts;\n        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n        const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);\n        let partIndex = 0;\n        let nodeIndex = 0;\n        let part;\n        let node = walker.nextNode();\n        // Loop through all the nodes and parts of a template\n        while (partIndex < parts.length) {\n            part = parts[partIndex];\n            if (!isTemplatePartActive(part)) {\n                this.__parts.push(undefined);\n                partIndex++;\n                continue;\n            }\n            // Progress the tree walker until we find our next part's node.\n            // Note that multiple parts may share the same node (attribute parts\n            // on a single element), so this loop may not run at all.\n            while (nodeIndex < part.index) {\n                nodeIndex++;\n                if (node.nodeName === 'TEMPLATE') {\n                    stack.push(node);\n                    walker.currentNode = node.content;\n                }\n                if ((node = walker.nextNode()) === null) {\n                    // We've exhausted the content inside a nested template element.\n                    // Because we still have parts (the outer for-loop), we know:\n                    // - There is a template in the stack\n                    // - The walker will find a nextNode outside the template\n                    walker.currentNode = stack.pop();\n                    node = walker.nextNode();\n                }\n            }\n            // We've arrived at our part's node.\n            if (part.type === 'node') {\n                const part = this.processor.handleTextExpression(this.options);\n                part.insertAfterNode(node.previousSibling);\n                this.__parts.push(part);\n            }\n            else {\n                this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));\n            }\n            partIndex++;\n        }\n        if (isCEPolyfill) {\n            document.adoptNode(fragment);\n            customElements.upgrade(fragment);\n        }\n        return fragment;\n    }\n}\n//# sourceMappingURL=template-instance.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module lit-html\n */\nimport { reparentNodes } from './dom.js';\nimport { boundAttributeSuffix, lastAttributeNameRegex, marker, nodeMarker } from './template.js';\n/**\n * Our TrustedTypePolicy for HTML which is declared using the html template\n * tag function.\n *\n * That HTML is a developer-authored constant, and is parsed with innerHTML\n * before any untrusted expressions have been mixed in. Therefor it is\n * considered safe by construction.\n */\nconst policy = window.trustedTypes &&\n    trustedTypes.createPolicy('lit-html', { createHTML: (s) => s });\nconst commentMarker = ` ${marker} `;\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\nexport class TemplateResult {\n    constructor(strings, values, type, processor) {\n        this.strings = strings;\n        this.values = values;\n        this.type = type;\n        this.processor = processor;\n    }\n    /**\n     * Returns a string of HTML used to create a `<template>` element.\n     */\n    getHTML() {\n        const l = this.strings.length - 1;\n        let html = '';\n        let isCommentBinding = false;\n        for (let i = 0; i < l; i++) {\n            const s = this.strings[i];\n            // For each binding we want to determine the kind of marker to insert\n            // into the template source before it's parsed by the browser's HTML\n            // parser. The marker type is based on whether the expression is in an\n            // attribute, text, or comment position.\n            //   * For node-position bindings we insert a comment with the marker\n            //     sentinel as its text content, like <!--{{lit-guid}}-->.\n            //   * For attribute bindings we insert just the marker sentinel for the\n            //     first binding, so that we support unquoted attribute bindings.\n            //     Subsequent bindings can use a comment marker because multi-binding\n            //     attributes must be quoted.\n            //   * For comment bindings we insert just the marker sentinel so we don't\n            //     close the comment.\n            //\n            // The following code scans the template source, but is *not* an HTML\n            // parser. We don't need to track the tree structure of the HTML, only\n            // whether a binding is inside a comment, and if not, if it appears to be\n            // the first binding in an attribute.\n            const commentOpen = s.lastIndexOf('<!--');\n            // We're in comment position if we have a comment open with no following\n            // comment close. Because <-- can appear in an attribute value there can\n            // be false positives.\n            isCommentBinding = (commentOpen > -1 || isCommentBinding) &&\n                s.indexOf('-->', commentOpen + 1) === -1;\n            // Check to see if we have an attribute-like sequence preceding the\n            // expression. This can match \"name=value\" like structures in text,\n            // comments, and attribute values, so there can be false-positives.\n            const attributeMatch = lastAttributeNameRegex.exec(s);\n            if (attributeMatch === null) {\n                // We're only in this branch if we don't have a attribute-like\n                // preceding sequence. For comments, this guards against unusual\n                // attribute values like <div foo=\"<!--${'bar'}\">. Cases like\n                // <!-- foo=${'bar'}--> are handled correctly in the attribute branch\n                // below.\n                html += s + (isCommentBinding ? commentMarker : nodeMarker);\n            }\n            else {\n                // For attributes we use just a marker sentinel, and also append a\n                // $lit$ suffix to the name to opt-out of attribute-specific parsing\n                // that IE and Edge do for style and certain SVG attributes.\n                html += s.substr(0, attributeMatch.index) + attributeMatch[1] +\n                    attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] +\n                    marker;\n            }\n        }\n        html += this.strings[l];\n        return html;\n    }\n    getTemplateElement() {\n        const template = document.createElement('template');\n        let value = this.getHTML();\n        if (policy !== undefined) {\n            // this is secure because `this.strings` is a TemplateStringsArray.\n            // TODO: validate this when\n            // https://github.com/tc39/proposal-array-is-template-object is\n            // implemented.\n            value = policy.createHTML(value);\n        }\n        template.innerHTML = value;\n        return template;\n    }\n}\n/**\n * A TemplateResult for SVG fragments.\n *\n * This class wraps HTML in an `<svg>` tag in order to parse its contents in the\n * SVG namespace, then modifies the template to remove the `<svg>` tag so that\n * clones only container the original fragment.\n */\nexport class SVGTemplateResult extends TemplateResult {\n    getHTML() {\n        return `<svg>${super.getHTML()}</svg>`;\n    }\n    getTemplateElement() {\n        const template = super.getTemplateElement();\n        const content = template.content;\n        const svgElement = content.firstChild;\n        content.removeChild(svgElement);\n        reparentNodes(content, svgElement.firstChild);\n        return template;\n    }\n}\n//# sourceMappingURL=template-result.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { isDirective } from './directive.js';\nimport { removeNodes } from './dom.js';\nimport { noChange, nothing } from './part.js';\nimport { TemplateInstance } from './template-instance.js';\nimport { TemplateResult } from './template-result.js';\nimport { createMarker } from './template.js';\nexport const isPrimitive = (value) => {\n    return (value === null ||\n        !(typeof value === 'object' || typeof value === 'function'));\n};\nexport const isIterable = (value) => {\n    return Array.isArray(value) ||\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        !!(value && value[Symbol.iterator]);\n};\n/**\n * Writes attribute values to the DOM for a group of AttributeParts bound to a\n * single attribute. The value is only set once even if there are multiple parts\n * for an attribute.\n */\nexport class AttributeCommitter {\n    constructor(element, name, strings) {\n        this.dirty = true;\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n        this.parts = [];\n        for (let i = 0; i < strings.length - 1; i++) {\n            this.parts[i] = this._createPart();\n        }\n    }\n    /**\n     * Creates a single part. Override this to create a differnt type of part.\n     */\n    _createPart() {\n        return new AttributePart(this);\n    }\n    _getValue() {\n        const strings = this.strings;\n        const l = strings.length - 1;\n        const parts = this.parts;\n        // If we're assigning an attribute via syntax like:\n        //    attr=\"${foo}\"  or  attr=${foo}\n        // but not\n        //    attr=\"${foo} ${bar}\" or attr=\"${foo} baz\"\n        // then we don't want to coerce the attribute value into one long\n        // string. Instead we want to just return the value itself directly,\n        // so that sanitizeDOMValue can get the actual value rather than\n        // String(value)\n        // The exception is if v is an array, in which case we do want to smash\n        // it together into a string without calling String() on the array.\n        //\n        // This also allows trusted values (when using TrustedTypes) being\n        // assigned to DOM sinks without being stringified in the process.\n        if (l === 1 && strings[0] === '' && strings[1] === '') {\n            const v = parts[0].value;\n            if (typeof v === 'symbol') {\n                return String(v);\n            }\n            if (typeof v === 'string' || !isIterable(v)) {\n                return v;\n            }\n        }\n        let text = '';\n        for (let i = 0; i < l; i++) {\n            text += strings[i];\n            const part = parts[i];\n            if (part !== undefined) {\n                const v = part.value;\n                if (isPrimitive(v) || !isIterable(v)) {\n                    text += typeof v === 'string' ? v : String(v);\n                }\n                else {\n                    for (const t of v) {\n                        text += typeof t === 'string' ? t : String(t);\n                    }\n                }\n            }\n        }\n        text += strings[l];\n        return text;\n    }\n    commit() {\n        if (this.dirty) {\n            this.dirty = false;\n            this.element.setAttribute(this.name, this._getValue());\n        }\n    }\n}\n/**\n * A Part that controls all or part of an attribute value.\n */\nexport class AttributePart {\n    constructor(committer) {\n        this.value = undefined;\n        this.committer = committer;\n    }\n    setValue(value) {\n        if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {\n            this.value = value;\n            // If the value is a not a directive, dirty the committer so that it'll\n            // call setAttribute. If the value is a directive, it'll dirty the\n            // committer if it calls setValue().\n            if (!isDirective(value)) {\n                this.committer.dirty = true;\n            }\n        }\n    }\n    commit() {\n        while (isDirective(this.value)) {\n            const directive = this.value;\n            this.value = noChange;\n            directive(this);\n        }\n        if (this.value === noChange) {\n            return;\n        }\n        this.committer.commit();\n    }\n}\n/**\n * A Part that controls a location within a Node tree. Like a Range, NodePart\n * has start and end locations and can set and update the Nodes between those\n * locations.\n *\n * NodeParts support several value types: primitives, Nodes, TemplateResults,\n * as well as arrays and iterables of those types.\n */\nexport class NodePart {\n    constructor(options) {\n        this.value = undefined;\n        this.__pendingValue = undefined;\n        this.options = options;\n    }\n    /**\n     * Appends this part into a container.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    appendInto(container) {\n        this.startNode = container.appendChild(createMarker());\n        this.endNode = container.appendChild(createMarker());\n    }\n    /**\n     * Inserts this part after the `ref` node (between `ref` and `ref`'s next\n     * sibling). Both `ref` and its next sibling must be static, unchanging nodes\n     * such as those that appear in a literal section of a template.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    insertAfterNode(ref) {\n        this.startNode = ref;\n        this.endNode = ref.nextSibling;\n    }\n    /**\n     * Appends this part into a parent part.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    appendIntoPart(part) {\n        part.__insert(this.startNode = createMarker());\n        part.__insert(this.endNode = createMarker());\n    }\n    /**\n     * Inserts this part after the `ref` part.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    insertAfterPart(ref) {\n        ref.__insert(this.startNode = createMarker());\n        this.endNode = ref.endNode;\n        ref.endNode = this.startNode;\n    }\n    setValue(value) {\n        this.__pendingValue = value;\n    }\n    commit() {\n        if (this.startNode.parentNode === null) {\n            return;\n        }\n        while (isDirective(this.__pendingValue)) {\n            const directive = this.__pendingValue;\n            this.__pendingValue = noChange;\n            directive(this);\n        }\n        const value = this.__pendingValue;\n        if (value === noChange) {\n            return;\n        }\n        if (isPrimitive(value)) {\n            if (value !== this.value) {\n                this.__commitText(value);\n            }\n        }\n        else if (value instanceof TemplateResult) {\n            this.__commitTemplateResult(value);\n        }\n        else if (value instanceof Node) {\n            this.__commitNode(value);\n        }\n        else if (isIterable(value)) {\n            this.__commitIterable(value);\n        }\n        else if (value === nothing) {\n            this.value = nothing;\n            this.clear();\n        }\n        else {\n            // Fallback, will render the string representation\n            this.__commitText(value);\n        }\n    }\n    __insert(node) {\n        this.endNode.parentNode.insertBefore(node, this.endNode);\n    }\n    __commitNode(value) {\n        if (this.value === value) {\n            return;\n        }\n        this.clear();\n        this.__insert(value);\n        this.value = value;\n    }\n    __commitText(value) {\n        const node = this.startNode.nextSibling;\n        value = value == null ? '' : value;\n        // If `value` isn't already a string, we explicitly convert it here in case\n        // it can't be implicitly converted - i.e. it's a symbol.\n        const valueAsString = typeof value === 'string' ? value : String(value);\n        if (node === this.endNode.previousSibling &&\n            node.nodeType === 3 /* Node.TEXT_NODE */) {\n            // If we only have a single text node between the markers, we can just\n            // set its value, rather than replacing it.\n            // TODO(justinfagnani): Can we just check if this.value is primitive?\n            node.data = valueAsString;\n        }\n        else {\n            this.__commitNode(document.createTextNode(valueAsString));\n        }\n        this.value = value;\n    }\n    __commitTemplateResult(value) {\n        const template = this.options.templateFactory(value);\n        if (this.value instanceof TemplateInstance &&\n            this.value.template === template) {\n            this.value.update(value.values);\n        }\n        else {\n            // Make sure we propagate the template processor from the TemplateResult\n            // so that we use its syntax extension, etc. The template factory comes\n            // from the render function options so that it can control template\n            // caching and preprocessing.\n            const instance = new TemplateInstance(template, value.processor, this.options);\n            const fragment = instance._clone();\n            instance.update(value.values);\n            this.__commitNode(fragment);\n            this.value = instance;\n        }\n    }\n    __commitIterable(value) {\n        // For an Iterable, we create a new InstancePart per item, then set its\n        // value to the item. This is a little bit of overhead for every item in\n        // an Iterable, but it lets us recurse easily and efficiently update Arrays\n        // of TemplateResults that will be commonly returned from expressions like:\n        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n        // If _value is an array, then the previous render was of an\n        // iterable and _value will contain the NodeParts from the previous\n        // render. If _value is not an array, clear this part and make a new\n        // array for NodeParts.\n        if (!Array.isArray(this.value)) {\n            this.value = [];\n            this.clear();\n        }\n        // Lets us keep track of how many items we stamped so we can clear leftover\n        // items from a previous render\n        const itemParts = this.value;\n        let partIndex = 0;\n        let itemPart;\n        for (const item of value) {\n            // Try to reuse an existing part\n            itemPart = itemParts[partIndex];\n            // If no existing part, create a new one\n            if (itemPart === undefined) {\n                itemPart = new NodePart(this.options);\n                itemParts.push(itemPart);\n                if (partIndex === 0) {\n                    itemPart.appendIntoPart(this);\n                }\n                else {\n                    itemPart.insertAfterPart(itemParts[partIndex - 1]);\n                }\n            }\n            itemPart.setValue(item);\n            itemPart.commit();\n            partIndex++;\n        }\n        if (partIndex < itemParts.length) {\n            // Truncate the parts array so _value reflects the current state\n            itemParts.length = partIndex;\n            this.clear(itemPart && itemPart.endNode);\n        }\n    }\n    clear(startNode = this.startNode) {\n        removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);\n    }\n}\n/**\n * Implements a boolean attribute, roughly as defined in the HTML\n * specification.\n *\n * If the value is truthy, then the attribute is present with a value of\n * ''. If the value is falsey, the attribute is removed.\n */\nexport class BooleanAttributePart {\n    constructor(element, name, strings) {\n        this.value = undefined;\n        this.__pendingValue = undefined;\n        if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {\n            throw new Error('Boolean attributes can only contain a single expression');\n        }\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n    }\n    setValue(value) {\n        this.__pendingValue = value;\n    }\n    commit() {\n        while (isDirective(this.__pendingValue)) {\n            const directive = this.__pendingValue;\n            this.__pendingValue = noChange;\n            directive(this);\n        }\n        if (this.__pendingValue === noChange) {\n            return;\n        }\n        const value = !!this.__pendingValue;\n        if (this.value !== value) {\n            if (value) {\n                this.element.setAttribute(this.name, '');\n            }\n            else {\n                this.element.removeAttribute(this.name);\n            }\n            this.value = value;\n        }\n        this.__pendingValue = noChange;\n    }\n}\n/**\n * Sets attribute values for PropertyParts, so that the value is only set once\n * even if there are multiple parts for a property.\n *\n * If an expression controls the whole property value, then the value is simply\n * assigned to the property under control. If there are string literals or\n * multiple expressions, then the strings are expressions are interpolated into\n * a string first.\n */\nexport class PropertyCommitter extends AttributeCommitter {\n    constructor(element, name, strings) {\n        super(element, name, strings);\n        this.single =\n            (strings.length === 2 && strings[0] === '' && strings[1] === '');\n    }\n    _createPart() {\n        return new PropertyPart(this);\n    }\n    _getValue() {\n        if (this.single) {\n            return this.parts[0].value;\n        }\n        return super._getValue();\n    }\n    commit() {\n        if (this.dirty) {\n            this.dirty = false;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.element[this.name] = this._getValue();\n        }\n    }\n}\nexport class PropertyPart extends AttributePart {\n}\n// Detect event listener options support. If the `capture` property is read\n// from the options object, then options are supported. If not, then the third\n// argument to add/removeEventListener is interpreted as the boolean capture\n// value so we should only pass the `capture` property.\nlet eventOptionsSupported = false;\n// Wrap into an IIFE because MS Edge <= v41 does not support having try/catch\n// blocks right into the body of a module\n(() => {\n    try {\n        const options = {\n            get capture() {\n                eventOptionsSupported = true;\n                return false;\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        window.addEventListener('test', options, options);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        window.removeEventListener('test', options, options);\n    }\n    catch (_e) {\n        // event options not supported\n    }\n})();\nexport class EventPart {\n    constructor(element, eventName, eventContext) {\n        this.value = undefined;\n        this.__pendingValue = undefined;\n        this.element = element;\n        this.eventName = eventName;\n        this.eventContext = eventContext;\n        this.__boundHandleEvent = (e) => this.handleEvent(e);\n    }\n    setValue(value) {\n        this.__pendingValue = value;\n    }\n    commit() {\n        while (isDirective(this.__pendingValue)) {\n            const directive = this.__pendingValue;\n            this.__pendingValue = noChange;\n            directive(this);\n        }\n        if (this.__pendingValue === noChange) {\n            return;\n        }\n        const newListener = this.__pendingValue;\n        const oldListener = this.value;\n        const shouldRemoveListener = newListener == null ||\n            oldListener != null &&\n                (newListener.capture !== oldListener.capture ||\n                    newListener.once !== oldListener.once ||\n                    newListener.passive !== oldListener.passive);\n        const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);\n        if (shouldRemoveListener) {\n            this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);\n        }\n        if (shouldAddListener) {\n            this.__options = getOptions(newListener);\n            this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);\n        }\n        this.value = newListener;\n        this.__pendingValue = noChange;\n    }\n    handleEvent(event) {\n        if (typeof this.value === 'function') {\n            this.value.call(this.eventContext || this.element, event);\n        }\n        else {\n            this.value.handleEvent(event);\n        }\n    }\n}\n// We copy options because of the inconsistent behavior of browsers when reading\n// the third argument of add/removeEventListener. IE11 doesn't support options\n// at all. Chrome 41 only reads `capture` if the argument is an object.\nconst getOptions = (o) => o &&\n    (eventOptionsSupported ?\n        { capture: o.capture, passive: o.passive, once: o.once } :\n        o.capture);\n//# sourceMappingURL=parts.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { AttributeCommitter, BooleanAttributePart, EventPart, NodePart, PropertyCommitter } from './parts.js';\n/**\n * Creates Parts when a template is instantiated.\n */\nexport class DefaultTemplateProcessor {\n    /**\n     * Create parts for an attribute-position binding, given the event, attribute\n     * name, and string literals.\n     *\n     * @param element The element containing the binding\n     * @param name  The attribute name\n     * @param strings The string literals. There are always at least two strings,\n     *   event for fully-controlled bindings with a single expression.\n     */\n    handleAttributeExpressions(element, name, strings, options) {\n        const prefix = name[0];\n        if (prefix === '.') {\n            const committer = new PropertyCommitter(element, name.slice(1), strings);\n            return committer.parts;\n        }\n        if (prefix === '@') {\n            return [new EventPart(element, name.slice(1), options.eventContext)];\n        }\n        if (prefix === '?') {\n            return [new BooleanAttributePart(element, name.slice(1), strings)];\n        }\n        const committer = new AttributeCommitter(element, name, strings);\n        return committer.parts;\n    }\n    /**\n     * Create parts for a text-position binding.\n     * @param templateFactory\n     */\n    handleTextExpression(options) {\n        return new NodePart(options);\n    }\n}\nexport const defaultTemplateProcessor = new DefaultTemplateProcessor();\n//# sourceMappingURL=default-template-processor.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { marker, Template } from './template.js';\n/**\n * The default TemplateFactory which caches Templates keyed on\n * result.type and result.strings.\n */\nexport function templateFactory(result) {\n    let templateCache = templateCaches.get(result.type);\n    if (templateCache === undefined) {\n        templateCache = {\n            stringsArray: new WeakMap(),\n            keyString: new Map()\n        };\n        templateCaches.set(result.type, templateCache);\n    }\n    let template = templateCache.stringsArray.get(result.strings);\n    if (template !== undefined) {\n        return template;\n    }\n    // If the TemplateStringsArray is new, generate a key from the strings\n    // This key is shared between all templates with identical content\n    const key = result.strings.join(marker);\n    // Check if we already have a Template for this key\n    template = templateCache.keyString.get(key);\n    if (template === undefined) {\n        // If we have not seen this key before, create a new Template\n        template = new Template(result, result.getTemplateElement());\n        // Cache the Template for this key\n        templateCache.keyString.set(key, template);\n    }\n    // Cache all future queries for this TemplateStringsArray\n    templateCache.stringsArray.set(result.strings, template);\n    return template;\n}\nexport const templateCaches = new Map();\n//# sourceMappingURL=template-factory.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { removeNodes } from './dom.js';\nimport { NodePart } from './parts.js';\nimport { templateFactory } from './template-factory.js';\nexport const parts = new WeakMap();\n/**\n * Renders a template result or other value to a container.\n *\n * To update a container with new values, reevaluate the template literal and\n * call `render` with the new result.\n *\n * @param result Any value renderable by NodePart - typically a TemplateResult\n *     created by evaluating a template tag like `html` or `svg`.\n * @param container A DOM parent to render to. The entire contents are either\n *     replaced, or efficiently updated if the same result type was previous\n *     rendered there.\n * @param options RenderOptions for the entire render tree rendered to this\n *     container. Render options must *not* change between renders to the same\n *     container, as those changes will not effect previously rendered DOM.\n */\nexport const render = (result, container, options) => {\n    let part = parts.get(container);\n    if (part === undefined) {\n        removeNodes(container, container.firstChild);\n        parts.set(container, part = new NodePart(Object.assign({ templateFactory }, options)));\n        part.appendInto(container);\n    }\n    part.setValue(result);\n    part.commit();\n};\n//# sourceMappingURL=render.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n *\n * Main lit-html module.\n *\n * Main exports:\n *\n * -  [[html]]\n * -  [[svg]]\n * -  [[render]]\n *\n * @packageDocumentation\n */\n/**\n * Do not remove this comment; it keeps typedoc from misplacing the module\n * docs.\n */\nimport { defaultTemplateProcessor } from './lib/default-template-processor.js';\nimport { SVGTemplateResult, TemplateResult } from './lib/template-result.js';\nexport { DefaultTemplateProcessor, defaultTemplateProcessor } from './lib/default-template-processor.js';\nexport { directive, isDirective } from './lib/directive.js';\n// TODO(justinfagnani): remove line when we get NodePart moving methods\nexport { removeNodes, reparentNodes } from './lib/dom.js';\nexport { noChange, nothing } from './lib/part.js';\nexport { AttributeCommitter, AttributePart, BooleanAttributePart, EventPart, isIterable, isPrimitive, NodePart, PropertyCommitter, PropertyPart } from './lib/parts.js';\nexport { parts, render } from './lib/render.js';\nexport { templateCaches, templateFactory } from './lib/template-factory.js';\nexport { TemplateInstance } from './lib/template-instance.js';\nexport { SVGTemplateResult, TemplateResult } from './lib/template-result.js';\nexport { createMarker, isTemplatePartActive, Template } from './lib/template.js';\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for lit-html usage.\n// TODO(justinfagnani): inject version number at build time\nif (typeof window !== 'undefined') {\n    (window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.4.1');\n}\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nexport const html = (strings, ...values) => new TemplateResult(strings, values, 'html', defaultTemplateProcessor);\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nexport const svg = (strings, ...values) => new SVGTemplateResult(strings, values, 'svg', defaultTemplateProcessor);\n//# sourceMappingURL=lit-html.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { isPrimitive } from '../lib/parts.js';\nimport { directive, NodePart } from '../lit-html.js';\n// For each part, remember the value that was last rendered to the part by the\n// unsafeHTML directive, and the DocumentFragment that was last set as a value.\n// The DocumentFragment is used as a unique key to check if the last value\n// rendered to the part was with unsafeHTML. If not, we'll always re-render the\n// value passed to unsafeHTML.\nconst previousValues = new WeakMap();\n/**\n * Renders the result as HTML, rather than text.\n *\n * Note, this is unsafe to use with any user-provided input that hasn't been\n * sanitized or escaped, as it may lead to cross-site-scripting\n * vulnerabilities.\n */\nexport const unsafeHTML = directive((value) => (part) => {\n    if (!(part instanceof NodePart)) {\n        throw new Error('unsafeHTML can only be used in text bindings');\n    }\n    const previousValue = previousValues.get(part);\n    if (previousValue !== undefined && isPrimitive(value) &&\n        value === previousValue.value && part.value === previousValue.fragment) {\n        return;\n    }\n    const template = document.createElement('template');\n    template.innerHTML = value; // innerHTML casts to string internally\n    const fragment = document.importNode(template.content, true);\n    part.setValue(fragment);\n    previousValues.set(part, { value, fragment });\n});\n//# sourceMappingURL=unsafe-html.js.map","/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { AttributePart, directive } from '../lit-html.js';\nconst previousValues = new WeakMap();\n/**\n * For AttributeParts, sets the attribute if the value is defined and removes\n * the attribute if the value is undefined.\n *\n * For other part types, this directive is a no-op.\n */\nexport const ifDefined = directive((value) => (part) => {\n    const previousValue = previousValues.get(part);\n    if (value === undefined && part instanceof AttributePart) {\n        // If the value is undefined, remove the attribute, but only if the value\n        // was previously defined.\n        if (previousValue !== undefined || !previousValues.has(part)) {\n            const name = part.committer.name;\n            part.committer.element.removeAttribute(name);\n        }\n    }\n    else if (value !== previousValue) {\n        part.setValue(value);\n    }\n    previousValues.set(part, value);\n});\n//# sourceMappingURL=if-defined.js.map","/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { createMarker, directive, NodePart, removeNodes, reparentNodes } from '../lit-html.js';\n// Helper functions for manipulating parts\n// TODO(kschaaf): Refactor into Part API?\nconst createAndInsertPart = (containerPart, beforePart) => {\n    const container = containerPart.startNode.parentNode;\n    const beforeNode = beforePart === undefined ? containerPart.endNode :\n        beforePart.startNode;\n    const startNode = container.insertBefore(createMarker(), beforeNode);\n    container.insertBefore(createMarker(), beforeNode);\n    const newPart = new NodePart(containerPart.options);\n    newPart.insertAfterNode(startNode);\n    return newPart;\n};\nconst updatePart = (part, value) => {\n    part.setValue(value);\n    part.commit();\n    return part;\n};\nconst insertPartBefore = (containerPart, part, ref) => {\n    const container = containerPart.startNode.parentNode;\n    const beforeNode = ref ? ref.startNode : containerPart.endNode;\n    const endNode = part.endNode.nextSibling;\n    if (endNode !== beforeNode) {\n        reparentNodes(container, part.startNode, endNode, beforeNode);\n    }\n};\nconst removePart = (part) => {\n    removeNodes(part.startNode.parentNode, part.startNode, part.endNode.nextSibling);\n};\n// Helper for generating a map of array item to its index over a subset\n// of an array (used to lazily generate `newKeyToIndexMap` and\n// `oldKeyToIndexMap`)\nconst generateMap = (list, start, end) => {\n    const map = new Map();\n    for (let i = start; i <= end; i++) {\n        map.set(list[i], i);\n    }\n    return map;\n};\n// Stores previous ordered list of parts and map of key to index\nconst partListCache = new WeakMap();\nconst keyListCache = new WeakMap();\n/**\n * A directive that repeats a series of values (usually `TemplateResults`)\n * generated from an iterable, and updates those items efficiently when the\n * iterable changes based on user-provided `keys` associated with each item.\n *\n * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,\n * meaning previous DOM for a given key is moved into the new position if\n * needed, and DOM will never be reused with values for different keys (new DOM\n * will always be created for new keys). This is generally the most efficient\n * way to use `repeat` since it performs minimum unnecessary work for insertions\n * and removals.\n *\n * IMPORTANT: If providing a `keyFn`, keys *must* be unique for all items in a\n * given call to `repeat`. The behavior when two or more items have the same key\n * is undefined.\n *\n * If no `keyFn` is provided, this directive will perform similar to mapping\n * items to values, and DOM will be reused against potentially different items.\n */\nexport const repeat = directive((items, keyFnOrTemplate, template) => {\n    let keyFn;\n    if (template === undefined) {\n        template = keyFnOrTemplate;\n    }\n    else if (keyFnOrTemplate !== undefined) {\n        keyFn = keyFnOrTemplate;\n    }\n    return (containerPart) => {\n        if (!(containerPart instanceof NodePart)) {\n            throw new Error('repeat can only be used in text bindings');\n        }\n        // Old part & key lists are retrieved from the last update\n        // (associated with the part for this instance of the directive)\n        const oldParts = partListCache.get(containerPart) || [];\n        const oldKeys = keyListCache.get(containerPart) || [];\n        // New part list will be built up as we go (either reused from\n        // old parts or created for new keys in this update). This is\n        // saved in the above cache at the end of the update.\n        const newParts = [];\n        // New value list is eagerly generated from items along with a\n        // parallel array indicating its key.\n        const newValues = [];\n        const newKeys = [];\n        let index = 0;\n        for (const item of items) {\n            newKeys[index] = keyFn ? keyFn(item, index) : index;\n            newValues[index] = template(item, index);\n            index++;\n        }\n        // Maps from key to index for current and previous update; these\n        // are generated lazily only when needed as a performance\n        // optimization, since they are only required for multiple\n        // non-contiguous changes in the list, which are less common.\n        let newKeyToIndexMap;\n        let oldKeyToIndexMap;\n        // Head and tail pointers to old parts and new values\n        let oldHead = 0;\n        let oldTail = oldParts.length - 1;\n        let newHead = 0;\n        let newTail = newValues.length - 1;\n        // Overview of O(n) reconciliation algorithm (general approach\n        // based on ideas found in ivi, vue, snabbdom, etc.):\n        //\n        // * We start with the list of old parts and new values (and\n        //   arrays of their respective keys), head/tail pointers into\n        //   each, and we build up the new list of parts by updating\n        //   (and when needed, moving) old parts or creating new ones.\n        //   The initial scenario might look like this (for brevity of\n        //   the diagrams, the numbers in the array reflect keys\n        //   associated with the old parts or new values, although keys\n        //   and parts/values are actually stored in parallel arrays\n        //   indexed using the same head/tail pointers):\n        //\n        //      oldHead v                 v oldTail\n        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n        //   newParts: [ ,  ,  ,  ,  ,  ,  ]\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new\n        //                                      item order\n        //      newHead ^                 ^ newTail\n        //\n        // * Iterate old & new lists from both sides, updating,\n        //   swapping, or removing parts at the head/tail locations\n        //   until neither head nor tail can move.\n        //\n        // * Example below: keys at head pointers match, so update old\n        //   part 0 in-place (no need to move it) and record part 0 in\n        //   the `newParts` list. The last thing we do is advance the\n        //   `oldHead` and `newHead` pointers (will be reflected in the\n        //   next diagram).\n        //\n        //      oldHead v                 v oldTail\n        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n        //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n        //                                      & newHead\n        //      newHead ^                 ^ newTail\n        //\n        // * Example below: head pointers don't match, but tail\n        //   pointers do, so update part 6 in place (no need to move\n        //   it), and record part 6 in the `newParts` list. Last,\n        //   advance the `oldTail` and `oldHead` pointers.\n        //\n        //         oldHead v              v oldTail\n        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n        //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldTail\n        //                                      & newTail\n        //         newHead ^              ^ newTail\n        //\n        // * If neither head nor tail match; next check if one of the\n        //   old head/tail items was removed. We first need to generate\n        //   the reverse map of new keys to index (`newKeyToIndexMap`),\n        //   which is done once lazily as a performance optimization,\n        //   since we only hit this case if multiple non-contiguous\n        //   changes were made. Note that for contiguous removal\n        //   anywhere in the list, the head and tails would advance\n        //   from either end and pass each other before we get to this\n        //   case and removals would be handled in the final while loop\n        //   without needing to generate the map.\n        //\n        // * Example below: The key at `oldTail` was removed (no longer\n        //   in the `newKeyToIndexMap`), so remove that part from the\n        //   DOM and advance just the `oldTail` pointer.\n        //\n        //         oldHead v           v oldTail\n        //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n        //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map: remove\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    5 and advance oldTail\n        //         newHead ^           ^ newTail\n        //\n        // * Once head and tail cannot move, any mismatches are due to\n        //   either new or moved items; if a new key is in the previous\n        //   \"old key to old index\" map, move the old part to the new\n        //   location, otherwise create and insert a new part. Note\n        //   that when moving an old part we null its position in the\n        //   oldParts array if it lies between the head and tail so we\n        //   know to skip it when the pointers get there.\n        //\n        // * Example below: neither head nor tail match, and neither\n        //   were removed; so find the `newHead` key in the\n        //   `oldKeyToIndexMap`, and move that old part's DOM into the\n        //   next head position (before `oldParts[oldHead]`). Last,\n        //   null the part in the `oldPart` array since it was\n        //   somewhere in the remaining oldParts still to be scanned\n        //   (between the head and tail pointers) so that we know to\n        //   skip that old part on future iterations.\n        //\n        //         oldHead v        v oldTail\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n        //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck: update & move 2\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    into place and advance\n        //                                      newHead\n        //         newHead ^           ^ newTail\n        //\n        // * Note that for moves/insertions like the one above, a part\n        //   inserted at the head pointer is inserted before the\n        //   current `oldParts[oldHead]`, and a part inserted at the\n        //   tail pointer is inserted before `newParts[newTail+1]`. The\n        //   seeming asymmetry lies in the fact that new parts are\n        //   moved into place outside in, so to the right of the head\n        //   pointer are old parts, and to the right of the tail\n        //   pointer are new parts.\n        //\n        // * We always restart back from the top of the algorithm,\n        //   allowing matching and simple updates in place to\n        //   continue...\n        //\n        // * Example below: the head pointers once again match, so\n        //   simply update part 1 and record it in the `newParts`\n        //   array.  Last, advance both head pointers.\n        //\n        //         oldHead v        v oldTail\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n        //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched: update 1\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n        //                                      & newHead\n        //            newHead ^        ^ newTail\n        //\n        // * As mentioned above, items that were moved as a result of\n        //   being stuck (the final else clause in the code below) are\n        //   marked with null, so we always advance old pointers over\n        //   these so we're comparing the next actual old value on\n        //   either end.\n        //\n        // * Example below: `oldHead` is null (already placed in\n        //   newParts), so advance `oldHead`.\n        //\n        //            oldHead v     v oldTail\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6] <- old head already used:\n        //   newParts: [0, 2, 1,  ,  ,  , 6]    advance oldHead\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n        //               newHead ^     ^ newTail\n        //\n        // * Note it's not critical to mark old parts as null when they\n        //   are moved from head to tail or tail to head, since they\n        //   will be outside the pointer range and never visited again.\n        //\n        // * Example below: Here the old tail key matches the new head\n        //   key, so the part at the `oldTail` position and move its\n        //   DOM to the new head position (before `oldParts[oldHead]`).\n        //   Last, advance `oldTail` and `newHead` pointers.\n        //\n        //               oldHead v  v oldTail\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n        //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]   head: update & move 4,\n        //                                     advance oldTail & newHead\n        //               newHead ^     ^ newTail\n        //\n        // * Example below: Old and new head keys match, so update the\n        //   old head part in place, and advance the `oldHead` and\n        //   `newHead` pointers.\n        //\n        //               oldHead v oldTail\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n        //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance oldHead &\n        //                                      newHead\n        //                  newHead ^  ^ newTail\n        //\n        // * Once the new or old pointers move past each other then all\n        //   we have left is additions (if old list exhausted) or\n        //   removals (if new list exhausted). Those are handled in the\n        //   final while loops at the end.\n        //\n        // * Example below: `oldHead` exceeded `oldTail`, so we're done\n        //   with the main loop.  Create the remaining part and insert\n        //   it at the new head position, and the update is complete.\n        //\n        //                   (oldHead > oldTail)\n        //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n        //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7\n        //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n        //                     newHead ^ newTail\n        //\n        // * Note that the order of the if/else clauses is not\n        //   important to the algorithm, as long as the null checks\n        //   come first (to ensure we're always working on valid old\n        //   parts) and that the final else clause comes last (since\n        //   that's where the expensive moves occur). The order of\n        //   remaining clauses is is just a simple guess at which cases\n        //   will be most common.\n        //\n        // * TODO(kschaaf) Note, we could calculate the longest\n        //   increasing subsequence (LIS) of old items in new position,\n        //   and only move those not in the LIS set. However that costs\n        //   O(nlogn) time and adds a bit more code, and only helps\n        //   make rare types of mutations require fewer moves. The\n        //   above handles removes, adds, reversal, swaps, and single\n        //   moves of contiguous items in linear time, in the minimum\n        //   number of moves. As the number of multiple moves where LIS\n        //   might help approaches a random shuffle, the LIS\n        //   optimization becomes less helpful, so it seems not worth\n        //   the code at this point. Could reconsider if a compelling\n        //   case arises.\n        while (oldHead <= oldTail && newHead <= newTail) {\n            if (oldParts[oldHead] === null) {\n                // `null` means old part at head has already been used\n                // below; skip\n                oldHead++;\n            }\n            else if (oldParts[oldTail] === null) {\n                // `null` means old part at tail has already been used\n                // below; skip\n                oldTail--;\n            }\n            else if (oldKeys[oldHead] === newKeys[newHead]) {\n                // Old head matches new head; update in place\n                newParts[newHead] =\n                    updatePart(oldParts[oldHead], newValues[newHead]);\n                oldHead++;\n                newHead++;\n            }\n            else if (oldKeys[oldTail] === newKeys[newTail]) {\n                // Old tail matches new tail; update in place\n                newParts[newTail] =\n                    updatePart(oldParts[oldTail], newValues[newTail]);\n                oldTail--;\n                newTail--;\n            }\n            else if (oldKeys[oldHead] === newKeys[newTail]) {\n                // Old head matches new tail; update and move to new tail\n                newParts[newTail] =\n                    updatePart(oldParts[oldHead], newValues[newTail]);\n                insertPartBefore(containerPart, oldParts[oldHead], newParts[newTail + 1]);\n                oldHead++;\n                newTail--;\n            }\n            else if (oldKeys[oldTail] === newKeys[newHead]) {\n                // Old tail matches new head; update and move to new head\n                newParts[newHead] =\n                    updatePart(oldParts[oldTail], newValues[newHead]);\n                insertPartBefore(containerPart, oldParts[oldTail], oldParts[oldHead]);\n                oldTail--;\n                newHead++;\n            }\n            else {\n                if (newKeyToIndexMap === undefined) {\n                    // Lazily generate key-to-index maps, used for removals &\n                    // moves below\n                    newKeyToIndexMap = generateMap(newKeys, newHead, newTail);\n                    oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);\n                }\n                if (!newKeyToIndexMap.has(oldKeys[oldHead])) {\n                    // Old head is no longer in new list; remove\n                    removePart(oldParts[oldHead]);\n                    oldHead++;\n                }\n                else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {\n                    // Old tail is no longer in new list; remove\n                    removePart(oldParts[oldTail]);\n                    oldTail--;\n                }\n                else {\n                    // Any mismatches at this point are due to additions or\n                    // moves; see if we have an old part we can reuse and move\n                    // into place\n                    const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);\n                    const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;\n                    if (oldPart === null) {\n                        // No old part for this value; create a new one and\n                        // insert it\n                        const newPart = createAndInsertPart(containerPart, oldParts[oldHead]);\n                        updatePart(newPart, newValues[newHead]);\n                        newParts[newHead] = newPart;\n                    }\n                    else {\n                        // Reuse old part\n                        newParts[newHead] =\n                            updatePart(oldPart, newValues[newHead]);\n                        insertPartBefore(containerPart, oldPart, oldParts[oldHead]);\n                        // This marks the old part as having been used, so that\n                        // it will be skipped in the first two checks above\n                        oldParts[oldIndex] = null;\n                    }\n                    newHead++;\n                }\n            }\n        }\n        // Add parts for any remaining new values\n        while (newHead <= newTail) {\n            // For all remaining additions, we insert before last new\n            // tail, since old pointers are no longer valid\n            const newPart = createAndInsertPart(containerPart, newParts[newTail + 1]);\n            updatePart(newPart, newValues[newHead]);\n            newParts[newHead++] = newPart;\n        }\n        // Remove any remaining unused old parts\n        while (oldHead <= oldTail) {\n            const oldPart = oldParts[oldHead++];\n            if (oldPart !== null) {\n                removePart(oldPart);\n            }\n        }\n        // Save order of new parts for next round\n        partListCache.set(containerPart, newParts);\n        keyListCache.set(containerPart, newKeys);\n    };\n});\n//# sourceMappingURL=repeat.js.map","/**\n * @license\n * Copyright (c) 2020 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { AttributePart, BooleanAttributePart, directive, EventPart, NodePart, PropertyPart } from '../lit-html.js';\n/**\n * Checks binding values against live DOM values, instead of previously bound\n * values, when determining whether to update the value.\n *\n * This is useful for cases where the DOM value may change from outside of\n * lit-html, such as with a binding to an `<input>` element's `value` property,\n * a content editable elements text, or to a custom element that changes it's\n * own properties or attributes.\n *\n * In these cases if the DOM value changes, but the value set through lit-html\n * bindings hasn't, lit-html won't know to update the DOM value and will leave\n * it alone. If this is not what you wantif you want to overwrite the DOM\n * value with the bound value no matter whatuse the `live()` directive:\n *\n *     html`<input .value=${live(x)}>`\n *\n * `live()` performs a strict equality check agains the live DOM value, and if\n * the new value is equal to the live value, does nothing. This means that\n * `live()` should not be used when the binding will cause a type conversion. If\n * you use `live()` with an attribute binding, make sure that only strings are\n * passed in, or the binding will update every render.\n */\nexport const live = directive((value) => (part) => {\n    let previousValue;\n    if (part instanceof EventPart || part instanceof NodePart) {\n        throw new Error('The `live` directive is not allowed on text or event bindings');\n    }\n    if (part instanceof BooleanAttributePart) {\n        checkStrings(part.strings);\n        previousValue = part.element.hasAttribute(part.name);\n        // This is a hack needed because BooleanAttributePart doesn't have a\n        // committer and does its own dirty checking after directives\n        part.value = previousValue;\n    }\n    else {\n        const { element, name, strings } = part.committer;\n        checkStrings(strings);\n        if (part instanceof PropertyPart) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            previousValue = element[name];\n            if (previousValue === value) {\n                return;\n            }\n        }\n        else if (part instanceof AttributePart) {\n            previousValue = element.getAttribute(name);\n        }\n        if (previousValue === String(value)) {\n            return;\n        }\n    }\n    part.setValue(value);\n});\nconst checkStrings = (strings) => {\n    if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {\n        throw new Error('`live` bindings can only contain a single expression');\n    }\n};\n//# sourceMappingURL=live.js.map","/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { directive } from '../lit-html.js';\nconst previousValues = new WeakMap();\n/**\n * Prevents re-render of a template function until a single value or an array of\n * values changes.\n *\n * Example:\n *\n * ```js\n * html`\n *   <div>\n *     ${guard([user.id, company.id], () => html`...`)}\n *   </div>\n * ```\n *\n * In this case, the template only renders if either `user.id` or `company.id`\n * changes.\n *\n * guard() is useful with immutable data patterns, by preventing expensive work\n * until data updates.\n *\n * Example:\n *\n * ```js\n * html`\n *   <div>\n *     ${guard([immutableItems], () => immutableItems.map(i => html`${i}`))}\n *   </div>\n * ```\n *\n * In this case, items are mapped over only when the array reference changes.\n *\n * @param value the value to check before re-rendering\n * @param f the template function\n */\nexport const guard = directive((value, f) => (part) => {\n    const previousValue = previousValues.get(part);\n    if (Array.isArray(value)) {\n        // Dirty-check arrays by item\n        if (Array.isArray(previousValue) &&\n            previousValue.length === value.length &&\n            value.every((v, i) => v === previousValue[i])) {\n            return;\n        }\n    }\n    else if (previousValue === value &&\n        (value !== undefined || previousValues.has(part))) {\n        // Dirty-check non-arrays by identity\n        return;\n    }\n    part.setValue(f());\n    // Copy the value if it's an array so that if it's mutated we don't forget\n    // what the previous values were.\n    previousValues.set(part, Array.isArray(value) ? Array.from(value) : value);\n});\n//# sourceMappingURL=guard.js.map","/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { TemplateInstance } from '../lib/template-instance.js';\nimport { directive, NodePart, reparentNodes, TemplateResult } from '../lit-html.js';\nconst templateCaches = new WeakMap();\n/**\n * Enables fast switching between multiple templates by caching the DOM nodes\n * and TemplateInstances produced by the templates.\n *\n * Example:\n *\n * ```\n * let checked = false;\n *\n * html`\n *   ${cache(checked ? html`input is checked` : html`input is not checked`)}\n * `\n * ```\n */\nexport const cache = directive((value) => (part) => {\n    if (!(part instanceof NodePart)) {\n        throw new Error('cache can only be used in text bindings');\n    }\n    let templateCache = templateCaches.get(part);\n    if (templateCache === undefined) {\n        templateCache = new WeakMap();\n        templateCaches.set(part, templateCache);\n    }\n    const previousValue = part.value;\n    // First, can we update the current TemplateInstance, or do we need to move\n    // the current nodes into the cache?\n    if (previousValue instanceof TemplateInstance) {\n        if (value instanceof TemplateResult &&\n            previousValue.template === part.options.templateFactory(value)) {\n            // Same Template, just trigger an update of the TemplateInstance\n            part.setValue(value);\n            return;\n        }\n        else {\n            // Not the same Template, move the nodes from the DOM into the cache.\n            let cachedTemplate = templateCache.get(previousValue.template);\n            if (cachedTemplate === undefined) {\n                cachedTemplate = {\n                    instance: previousValue,\n                    nodes: document.createDocumentFragment(),\n                };\n                templateCache.set(previousValue.template, cachedTemplate);\n            }\n            reparentNodes(cachedTemplate.nodes, part.startNode.nextSibling, part.endNode);\n        }\n    }\n    // Next, can we reuse nodes from the cache?\n    if (value instanceof TemplateResult) {\n        const template = part.options.templateFactory(value);\n        const cachedTemplate = templateCache.get(template);\n        if (cachedTemplate !== undefined) {\n            // Move nodes out of cache\n            part.setValue(cachedTemplate.nodes);\n            part.commit();\n            // Set the Part value to the TemplateInstance so it'll update it.\n            part.value = cachedTemplate.instance;\n        }\n    }\n    part.setValue(value);\n});\n//# sourceMappingURL=cache.js.map","export const is_mac = navigator.platform === 'MacIntel'\r\nexport const is_iOS = /iPad|iPhone|iPod/.test( navigator.platform) ||\r\n\t\t\t\t\t\t\t (is_mac && navigator.maxTouchPoints > 1)\r\nexport const is_safari = /^((?!chrome|android).)*safari/i.test( navigator.userAgent)\r\nexport const isScrollbarVisible = (element) => element.scrollHeight > element.clientHeight\r\n\r\n/** optional chaining util since iOS 12 doesn't support it natively and old iPads are stuck at this version */\r\nexport const chain = (obj, ...keys) => { /// chain( this, 'prop', 'sub-prop')\r\n\tfor( let k of keys) obj = obj && obj[ k] || undefined\r\n\treturn obj\r\n}\r\n// Helper to return the class or empty string if condition is false\r\nexport const strIf = (str, condition) => condition ? str : ''\r\nexport const q = sel => document.querySelector( sel)\r\nexport const qAll = sel => document.querySelectorAll( sel)\r\nexport const clone = obj => JSON.parse( JSON.stringify( obj))\r\nexport const ctor = target => Object.getPrototypeOf( target).constructor\r\nexport const pathSegments = str => trimPath( str).split('/');\r\nexport const trimPath = str => /^\\/?(.+?)\\/?$/.exec( str)[1];\r\n/** like toFixed but no rounding for the last digit, and works with string input. return a string from a number truncated to x decimal places */\r\nexport function cleanNum( num, places=3){\r\n\tif( typeof num === 'string')\r\n\t\tnum = parseFloat( num)\r\n\treturn num.toFixed( places+1).slice(0,-1) /// remove last which is rounded\r\n}\r\nexport const isObject = o => !!o && typeof o === 'object' && ! Array.isArray( o)\r\n/**\r\n * parse a flat object-like string, without surrounding braces\r\n * matches only last comma after a colon so we can use comma in value\r\n*/\r\nexport function objectFromString( string, remove_key_prefix=''){\r\n\tif( remove_key_prefix){\r\n\t\tconst re = new RegExp( remove_key_prefix, 'g')\r\n\t\tstring = string.replace(re,'')\r\n\t}\r\n\tlet arr = string.trim()\r\n\t\t.match(/[^:,\\s]+\\:[^:]+((?=\\s*,\\s*)|$)/g)\r\n\t\t.map( part => part.split(/\\s*:\\s*/) )\r\n\r\n\t\t// -> all not [:, ] then \":\" then all not [:] ending with comma or end\r\n\r\n\treturn Object.fromEntries( arr)\r\n}\r\n\r\nconst containsHTMLEntities = str => /&[\\d\\w]+;/.test( str)\r\n// based on standard syntax: no space after '<' nor before '>' : <xxx> <xxx xxx=\"\">\r\nconst containsHTMLElements = str => /\\<\\S.*?\\S\\>/.test( str)\r\nexport const containsHTML = str => {\r\n\t// log('check', 'check if contains HTML:', str, '->', containsHTMLElements( str) || containsHTMLEnties( str))\r\n\treturn containsHTMLElements( str) || containsHTMLEntities( str)\r\n}\r\n\r\nexport const loadScriptAsync = src => new Promise( (resolve, reject) => {\r\n\tlet s = document.createElement('script')\r\n\ts.onload = () => resolve( src)\r\n\ts.onerror = err => reject( err)\r\n\ts.async = true\r\n\tdocument.head.appendChild( s)\r\n\ts.src = src\r\n})\r\nexport const loadScriptsAsync = (scripts, path='') =>\r\n\tPromise.all( scripts.map( name => loadScriptAsync( path + name)))\r\n\r\nexport const loadStyleSheetAsync = href => new Promise( (resolve, reject) => {\r\n\t// console.warn('Load script:', src)\r\n\tlet s = document.createElement('link')\r\n\ts.onerror = e => console.error('Error loading stylesheet:', href)\r\n\ts.onload = () => resolve( href)\r\n\ts.rel = 'stylesheet'\r\n\tdocument.head.appendChild( s)\r\n\ts.href = href\r\n})\r\n/**\r\n * throttle: callback is called at a max speed during events\r\n * debounce: callback is only called after events have stopped\r\n * creates a debouced version of a function; Use for debouncing or throttling a rapid event callback\r\n * @param {function} callback The function to call back debouced / throttled\r\n * @param {number} [debounce_dly=1000] ms - callback is debounced (skipped) as long as events are fired within this delay.\r\n * @param {number} [throttle_dly=0] ms - if>0, callback will be triggered at this interval even if events are fired faster.\r\n * @param {bool} [initial_call=false] fire the callback once at start\r\n * @param {number} [precision=100] ms - period for checking elapsed time, no need to check as often as events...\r\n */\r\nexport function debounce( callback, debounce_dly=1000, throttle_dly=0, initial_call=false, precision=100){\r\n\r\n\tlet last_call = 0, onInterval_running = false, _params, initially_called = false, elapsed, t3, last_callback, now\r\n\t//console.log('debounce:', debounce_dly)\r\n\treturn function onCall( ...params){\r\n\t\t_params = params\r\n\t\tnow = Date.now()\r\n\t\tlast_call = now\r\n\r\n\t\tif( !onInterval_running){\r\n\t\t\tonInterval_running = true\r\n\t\t\tlast_callback = now /// first time just use start time\r\n\t\t\tt3 = setInterval( onInterval, precision)\r\n\t\t}\r\n\t}\r\n\t/** periodically watch if elapsed time since last callback is > dly */\r\n\tfunction onInterval(){\r\n\t\tnow = Date.now()\r\n\t\telapsed = now - last_call\r\n\r\n\t\tif( initial_call && !initially_called){\r\n\t\t\tinitially_called = true\r\n\t\t\tlast_callback = now\r\n\t\t\tcallback( ..._params)\r\n\t\t}\r\n\t\telse if( elapsed > debounce_dly){ /// last callback was enough time ago\r\n\t\t\tonInterval_running = false\r\n\t\t\tinitially_called = false\r\n\t\t\tlast_callback = now\r\n\t\t\tclearInterval( t3)\r\n\t\t\t//console.log('check', 'callback for debounce_dly')\r\n\t\t\tcallback( ..._params)\r\n\t\t}\r\n\t\telse if( throttle_dly){\r\n\t\t\tif( now - last_callback > throttle_dly){\r\n\t\t\t\tlast_callback = now\r\n\t\t\t\t//console.log('check', 'callback for throttle_dly')\r\n\t\t\t\tcallback( ..._params)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport function sleep(ms) {\r\n  return new Promise(resolve => setTimeout(resolve, ms))\r\n}\r\n/** -> await nextFrame() */\r\nexport function nextFrame(){\r\n  return new Promise( resolve => requestAnimationFrame( resolve))\r\n}\r\n/** end inclusive. If using a single param (end) => from 1 to end\r\n * if we allow zero, it means range(0,0) will return [0];\r\n * for use when we\r\n*/\r\nexport const range =\r\n\t(start, end, allow_reverse=true) => {\r\n\r\n\t\t// some apps use: range( 1, arr.length)\r\n\t\t// and expect empty range if arr length is 0\r\n\t\tif( !allow_reverse && end < start)\r\n\t\t\treturn []\r\n\r\n\t\tif( end === undefined){ // single param = from 1 to N: range(3) -> 1-3 => [1,2,3]\r\n\t\t\tend = start\r\n\t\t\tstart = 1\r\n\t\t}\r\n\t\telse if( end === start)\r\n\t\t\treturn [start] // range(1,1) => [1], range(0,0) => [0]\r\n\r\n\t\tconst reverse = end < start\r\n\t\tif( reverse)\r\n\t\t\t[start,end] = [end,start]\r\n\r\n\t\tconst arr = Array.from({ length: (end - start + 1) }, (v, k) => k + start)\r\n\t\treturn reverse ? arr.reverse() : arr\r\n\t}\r\n\r\n/** returns an array of number ranging from start to end inclusive, or from 1 to X if passing a single param */\r\nexport const numberRange = (start, end) => {\r\n\tif( !end){ end = start; start = 1 }\r\n\treturn Array.from({length: (end - start+1)}, (v, k) => k + start)\r\n}\r\nexport const clamp = (num,min,max) => Math.max( Math.min( num, max), min)\r\nexport const linearScaling = ( oldMin, oldMax, newMin, newMax, oldValue) =>\r\n\tparseFloat((((oldValue - oldMin) * (newMax - newMin)) / (oldMax - oldMin))  + newMin)\r\n/**\r\n * @param t time position [0-1]\r\n * @param p power\r\n * @return transformed (eased) value [0-1]\r\n */\r\nexport const ease = {\r\n\tlinear: t => t,\r\n\tin: (t,p=2) => Math.pow( t, p),\r\n\tout: (t,p=2) => 1 - Math.abs( Math.pow( t - 1, p)),\r\n\tinOut: (t,p=2) => t < .5 ? ease.in( t * 2, p) / 2 : ease.out( 2 * t - 1, p) / 2 + 0.5,\r\n\toutIn: (t,p=2) => t < .5 ? ease.out( t * 2, p) / 2 : ease.in( 2 * (t - 0.5), p) / 2 + 0.5,\r\n\tinCirc: t => -1 * (Math.sqrt(1 - t*t) - 1),\r\n\toutCirc: t => 1 * Math.sqrt(1 - (t=t-1)*t),\r\n\tinOutCirc: \tt => (t*=2) < 1 ?\r\n\t\t-1/2 * (Math.sqrt(1 - t*t) - 1) :\r\n\t\t1/2 * (Math.sqrt(1 - (t-=2)*t) + 1),\r\n\tinExpo: t => (t==0) ? 0 : 1 * Math.pow(2, 10 * (t/1 - 1)) ,\r\n\toutExpo: t => (t==1) ? 1 : 1 * (-Math.pow(2, -10 * t/1) + 1),\r\n\tinOutExpo: t => t==0 ? 0 : t==1 ? 1 :\r\n\t\t(t*=2) < 1 ?\r\n\t\t\t1/2 * Math.pow(2, 10 * (t - 1)) :\r\n\t\t\t1/2 * (-Math.pow(2, -10 * --t) + 2),\r\n\r\n\t/// VERY SIMILAR TO NORMAL EASE IN / OUT\r\n\teaseInSine: (t, b=0, c=1, d=1) => -c * Math.cos(t/d * (Math.PI/2)) + c + b,\r\n\teaseOutSine: (t, b=0, c=1, d=1) => c * Math.sin(t/d * (Math.PI/2)) + b,\r\n\teaseInOutSine: (t, b=0, c=1, d=1) => -c/2 * (Math.cos(Math.PI*t/d) - 1) + b\r\n}\r\n/**\r\n * Smooth out the curve of an ease for more subtle effect\r\n * @param ease one of ease methods\r\n * @param smoothing [0-1] ?\r\n * ex: const myease = smoothedEase( ease.out, .5); myease(.1, 3)\r\n */\r\nexport const smoothedEase =\r\n\t(ease, smoothing) => /// return a new function taking (value, )\r\n\t\t(val, power=2, eased) => /// eased is just a  var declaration, unused param...\r\n\t\t\t(eased = ease( val, power)) - (eased - val) * smoothing\r\n\r\n/**\r\n * Applies a temporary class; e.g. call attention to a button\r\n * classList can be string, space sep strings, or an array\r\n * @param duration sec time before removing class(es)\r\n*/\r\nexport function tempClass( el, clss=[], durations=1){\r\n\tif( typeof clss === 'string')\r\n\t\tclss = clss.split(' ')\r\n\tel.classList.add( ...clss)\r\n\tif( !Array.isArray( durations))\r\n\t\tdurations = [durations]\r\n\r\n\tif( durations && durations.length>1){\r\n\t\t//durations.sort( (a,b) => a-b)\r\n\t\tdurations.reduce( (prev,current) => {\r\n\t\t\tif( prev > current) throw 'tempClass durations must be in increasing order'\r\n\t\t})\r\n\t\t//console.log('classes:', clss, durations)\r\n\t\tlet i = 0\r\n\t\tfor( let dur of durations)\r\n\t\t\tsetTimeout( () => {\r\n\t\t\t\t//console.log('remove class:', clss[i], 'dur:', dur)\r\n\t\t\t\tel.classList.remove( clss[i++])\r\n\t\t\t}, dur*1000)\r\n\t}\r\n\telse\r\n\t\tsetTimeout( () => { el.classList.remove( ...clss) }, durations ? durations[0]*1000 : 0)\r\n}\r\n\r\n/** multiple props only if use same vals */\r\nexport function tempProp( el, props_vals=[], duration=1000){\r\n\tfor( let [prop, vals] of props_vals){\r\n\t\t//log('check', 'set prop val', prop, vals[0])\r\n\t\tel[ prop] = vals[0]\r\n\t\tsetTimeout( () => {\r\n\t\t\tel[ prop] = vals[1]\r\n\t\t\t//log('check', 'set prop val', prop, vals[1])\r\n\t\t}, duration)\r\n\t}\r\n}\r\nexport function el( tag, content, attribs={}){\r\n\tlet elem = document.createElement(tag)\r\n\tfor( let k in attribs)\r\n\t\telem.setAttribute( k, attribs[ k])\r\n\tif( content){\r\n\t\tif( typeof content === 'string')\r\n\t\t\telem.innerHTML = content\r\n\t\telse if( content instanceof HTMLElement)\r\n\t\t\telem.appendChild( content)\r\n\t\telse throw Error('el(,content,) => Unknown content type')\r\n\t}\r\n\treturn elem\r\n}\r\n/** Fisher-Yates shuffle\r\n * @param {Array} array\r\n * @param {Boolean} in_place if the shuffle should be done on the original array or if a new array should be used\r\n * @return array or new array if in_place=false\r\n*/\r\nexport function shuffle( array, in_place=true) {\r\n\tif( !in_place) array = array.concat()\r\n  var current_index = array.length, temporary_value, random_index\r\n  /// While there remain elements to shuffle...\r\n  while( 0 !== current_index){\r\n    /// Pick a remaining element...\r\n    random_index = Math.floor( Math.random() * current_index)\r\n    current_index -= 1\r\n    /// And swap it with the current element.\r\n    temporary_value = array[ current_index]\r\n    array[ current_index] = array[ random_index]\r\n    array[ random_index] = temporary_value\r\n  }\r\n  return array\r\n}\r\n\r\n/**\r\n * randomize while keeping together items with a particular field\r\n * eg with a 'num' field, values would be: 1 3 1 2 1 1  =>  1 1 1 3 3 3 2 2 2\r\n * @param {Array} array\r\n * @param {string} const_field the field to group items\r\n */\r\nexport function intraShuffle( array, const_field){\r\n\r\n\tconst arrays = new Map()\r\n\tfor( let item of array){\r\n\t\tlet val = item[ const_field]\r\n\t\tif( arrays.has( val))\r\n\t\t\tarrays.get( val).push( item)\r\n\t\telse\r\n\t\t\tarrays.set( val, [ item])\r\n\t}\r\n\tlet rtrn = []\r\n\tfor( let arr of arrays.values()){\r\n\t\trtrn.push( ...shuffle( arr, true))\r\n\t}\r\n\treturn rtrn\r\n}\r\n\r\n/** Get the highest numeric value in an array */\r\nexport const highest = arr => {\r\n\treturn arr.reduce( (last_val, val) => Math.max( last_val, val), 0)\r\n}\r\n\r\n/**\r\n * Get the next or prev value of an array with current value\r\n * @param {any} from_val\t- initial value\r\n * @param {array} vals\t\t- array\r\n * @param {string} dir \t\t- symbolic representation of direction and wrapping //// >> << >>| |<< + - up down 1 -1\r\n * @return {any}\t\t\t\t\t-\tthe next or prev value\r\n * // Usage:  wrap -> cycle( val, vals, '>>') \tno-wrap -> cycle( val, vals, '>>|')\r\n */\r\nexport const cycle = (from_val, vals, dir='>>', wrap=null) => {\r\n\t//log('check','cycle:', from_val, vals)\r\n\treturn /(\\>\\>|\\+|up|1)/.test(dir) ?\r\n\tvals[ nextIndexOf( from_val, vals, wrap !== null ? wrap : !dir.endsWith('|')) ] :\r\n\tvals[ prevIndexOf( from_val, vals, wrap !== null ? wrap : !dir.startsWith('|')) ];\r\n}\r\n// MULTI-VALUE STATE VALUE CYCLING INSTEAD OF CLASS/NO-CLASS TOGGLING\r\n// ex: data-state='off' data-states='on,off' : on click => cycleDataStates( e.target)\r\nexport function cycleDataStates( target, wrap=true){\r\n\tif( !target.dataset.states && !target.states){\r\n\t\tconsole.error('NO DATA-STATES ON TARGET:', target)\r\n\t\treturn\r\n\t}\r\n\tconst states = target.states || target.dataset.states.split( /\\s*,?\\s*/)// at least space sep, maybe comma sep\r\n\tconst actual_state = target.dataset.state\r\n\ttarget.dataset.state = states[ nextIndexOf( actual_state, states, wrap)]\r\n\treturn target.dataset.state\r\n}\r\nexport const nextIndexOf = (val, vals, wrap=true) =>\r\n\tnextIndex( vals.indexOf( val), vals.length, wrap)\r\nexport const prevIndexOf = (val, vals, wrap=true) =>\r\n\tprevIndex( vals.indexOf( val), vals.length, wrap)\r\n\r\n\r\nexport const nextIndex = (index, len, wrap=true) =>\r\n\t!wrap&&index===len-1 ? len-1 : wrapIndex( ++index, len)\r\nexport const prevIndex = (index, len, wrap=true) =>\r\n\t!wrap&&index===0 ? 0 : wrapIndex( --index, len)\r\nexport const wrapIndex = (index, len) => // also wraps negative index!! (e.g. -1,4 => 3)\r\n\t((index % len) + len) % len\r\n\r\n\r\nexport function setIntervalImmediately( func, interval) {\r\n  func()\r\n  return setInterval(func, interval)\r\n}\r\n/**\r\n\t* // Snaps a value on a virtual grid to the closest side  //\r\n\t* +  works with floats and negative values\r\n\t* +  e.g. snap(84, 40) => 80\r\n\t* @param\t\t{Number}\t\tval\t\t\t\t- initial value\r\n\t* @param\t\t{Number}\t\tstep\t\t\t- modulo value, defines the grid step size\r\n\t* @param\t\t{Number}\t\toffset\t\t- use if the grid is not positioned at a multiple of step (self-synced?)\r\n\t* \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\te.g. grid start X = 103, step=20: 103 or 3 as offset\r\n\t* @param\t\t{Number}\t\tthreshold\t- creates a dead spot in the middle of two snap points:\r\n\t* \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif val is too far from snap value (> threshold), return original value\r\n\t* \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// e.g. snap = 30, threshold = 8 => [0-8] snaps to 0, [22-30] snaps to 30, else => no snap\r\n\t*\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// use less than a half step. step * .4 means 20% dead spot -> (.4|.4) + .2 + (.4|.4)\r\n\t*\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// we can set a percent deadspot by using a string: '30%'\r\n\t* @return\t\t{Number}\t\t\t\t\t\t\t- the value snapped to the closest point\r\n\t*/\r\nexport function snap( val, step, offset=0, threshold=null){\r\n\tlet original = val\r\n\tif( typeof threshold === 'string') ////  % deadspot\r\n\t\tthreshold = (1 - parseInt( threshold) / 100) / 2 * step\r\n\r\n\tval = val - offset /// remove offset\r\n\tlet distL = val - snapFloor( val, step), \t/// distance from val to the left step\r\n\t\t distR = snapCeil( val, step) - val \t\t/// distance from val to the right step\r\n\tif( Math.abs( distL) < Math.abs( distR)){\r\n\t\tif( threshold && Math.abs( distL) > threshold)\r\n\t\t\treturn original // or null\r\n\t\treturn val - distL + offset\r\n\t}\r\n\telse {\r\n\t\tif( threshold && Math.abs( distR) > threshold)\r\n\t\t\treturn original\r\n\t\treturn val + distR + offset\r\n\t}\r\n}\r\n/**\r\n\t* snap a value on a grid to the higher value\r\n\t* @return {Number} value increased to the next grid point\r\n\t*/\r\nexport function snapCeil( val, mod){\r\n\t/// remove remainder and add a grid step, unless negative value:\r\n\treturn val > 0 ?\r\n\t\tval - val % mod + mod :\r\n\t\tval - val % mod\r\n}\r\n/**\r\n\t* snap a value on a grid to the lower value\r\n\t* @return  value decreased to the previous grid point\r\n\t*/\r\nexport function snapFloor( val, mod){\r\n\t/// remove remainder and if negative value remove a grid step\r\n\treturn val > 0 ?\r\n\t\tval - val % mod :\r\n\t\tval - val % mod - mod\r\n}\r\n/** Only get the unique items of an array, object items are checked by equiv(). */\r\nexport function unique( arr, compare_objects = false){\r\n\tif (!compare_objects)\r\n\t\treturn Array.from( new Set( arr))\r\n\telse {\r\n\t\tlet out = []\r\n\t\t/// b/c won't be compared to a..., so dupes will be added once\r\n\t\tfor( let i = 0; i < arr.length; i++){\r\n\t\t\tlet a = arr[ i]\r\n\t\t\tlet is_unique = true\r\n\t\t\tfor( let j = i + 1; j < arr.length; j++){\r\n\t\t\t\tlet b = arr[j]\r\n\t\t\t\tif( equiv(a, b)){\r\n\t\t\t\t\tis_unique = false\r\n\t\t\t\t\tbreak\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif( is_unique)\r\n\t\t\t\tout.push( a)\r\n\t\t}\r\n\t\treturn out\r\n\t}\r\n}\r\n/**\r\n * check if two objects are equivalent (if all values of A are found on B)\r\n * @param {*} objA\r\n * @param {*} objB\r\n * @param {boolean} [only_check_common_keys=false] allow undefined keys on any\r\n * @param {boolean} [shallow=true]\r\n * @returns\r\n */\r\nexport function equiv( objA, objB, only_check_common_keys=false, shallow=true){\r\n\t//console.log('equiv:', objA, objB)\r\n\tif( only_check_common_keys){\r\n\t\tfor( let k in objA){\r\n\t\t\tif( shallow && !objA.hasOwnProperty( k)) /// only_check_common_keys\r\n\t\t\t\tcontinue\r\n\r\n\t\t\tconst key_exists =\r\n\t\t\t\tshallow && objA.hasOwnProperty( k) && objB.hasOwnProperty( k) ||\r\n\t\t\t\t!shallow && k in objA && k in objB\r\n\t\t\t//// if key do not exist on both, ignore\r\n\t\t\tif( key_exists && objA[ k] !== objB[ k]){\r\n\t\t\t\treturn false\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tfor( let k in objA){\r\n\t\t\tif( shallow && !objA.hasOwnProperty( k))\r\n\t\t\t\tcontinue\r\n\t\t\t//// values differ, or k could be undefined in A\r\n\t\t\tif( objA[ k] !== objB[ k])\r\n\t\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\treturn true\r\n}\r\nexport const tag = elem => elem.tagName.toLowerCase()\r\n\r\n\r\nconst bags = {}\r\n\r\nexport function createBag2D( name, units, tens){\r\n\r\n\tif( bags[ name]) throw 'createBag2D :: bag name already taken: ' + name\r\n\r\n\tbags[ name] = {\r\n\t\tlist: [],\r\n\t\tunits, \t\t//// static, stay as defined /// { numbers: [], chances (for those): Number }\r\n\t\ttens, \t\t//// static, stay as defined /// { numbers: [], chances (for those): Number }\r\n\t\ttemp_units: [],\r\n\t\ttemp_tens: []\r\n\t}\r\n\t//log('warn','bag2D created:', name)\r\n}\r\n\r\n\r\n\r\n/**  */\r\nexport function pickNumberInBag( bag_name){\r\n\r\n\t//log('check','pickNumberInBag:', bag_name)\r\n\tconst bag = bags[ bag_name]\r\n\r\n\tif( !bag.list.length)\r\n\t\tfillBag( bag)\r\n\r\n\tlet num = pickRandomInArray( bag.list)\r\n\t/// split num into units and tens\r\n\tlet [tens,units] = num.toString().padStart(2,'0').split('')\r\n\t/// return [tens, units, num]\r\n\treturn [parseInt(tens), parseInt(units), num]\r\n}\r\n\r\n/** refills a bag with random chances according to bag config */\r\nfunction fillBag( bag){\r\n\r\n\tbag.list.length = 0\r\n\r\n\t//// preprocess, cache?\r\n\tlet units_chances = 0, \t//// bag.units_chances\r\n\t\t\ttens_chances = 0\t\t//// bag.tens_chances\r\n\tbag.units.forEach( num => { units_chances += num.chances * num.numbers.length })\r\n\tbag.tens.forEach( num => { tens_chances += num.chances * num.numbers.length })\r\n\tlet total_chances = units_chances + tens_chances\r\n\r\n\tfor( let {numbers, chances} of bag.units){\r\n\t\tchances *= numbers.length /// total chances for those numbers\r\n\t\tlet relative_chances = Math.round( chances / units_chances * total_chances)\r\n\t\tfor( let i=0; i<relative_chances; i++)\r\n\t\t\tbag.temp_units.push( getRandomInArray( numbers) )\r\n\t}\r\n\tfor( let {numbers, chances} of bag.tens){\r\n\t\tchances *= numbers.length\r\n\t\tlet relative_chances = Math.round( chances / tens_chances * total_chances)\r\n\t\t/// Normalize...\r\n\t\tconst n = 100\r\n\t\trelative_chances = Math.round( relative_chances / total_chances * n)\r\n\r\n\t\tfor( let i=0; i<relative_chances; i++)\r\n\t\t\tbag.temp_tens.push( getRandomInArray( numbers) * 10)\r\n\t}\r\n\tlog('check', 'bag.temp_units.length:', bag.temp_units.length)\r\n\tlog('check', 'bag.temp_tens.length:', bag.temp_tens.length)\r\n\t//// recombine tens and units into .list\r\n\twhile( bag.temp_units.length){\r\n\t\tlet tens = bag.temp_tens.length ? pickRandomInArray( bag.temp_tens) : 0\r\n\t\tbag.list.push( tens + bag.temp_units.pop() )\r\n\t}\r\n\tbag.temp_units.length = 0\r\n\tbag.temp_tens.length = 0\r\n\r\n\tbag.list.sort()\r\n\tbag.list = [...new Set( bag.list)] //// make unique\r\n\t//log('bag:', bag.list)\r\n}\r\n\r\n/** get one random item from an array */\r\nexport const getRandomInArray = arr => arr[ Math.floor( Math.random() * arr.length)]\r\n\r\n\r\n/** remove one random item from an array and return it */\r\nexport const pickRandomInArray = arr => arr.splice( Math.floor( Math.random()*arr.length), 1)[0]\r\n\r\n/** end inclusive (1,3) will be 1, 2 or 3 */\r\nexport function randomNumberFromRange( start, end, exclude=null, exclude_predicament=null){\r\n\tif( exclude!==null && !Array.isArray(exclude))\r\n\t\texclude = [exclude]\r\n\tif( start === end)\r\n\t\treturn start\r\n\tif( end < start){\r\n\t\tlet new_start = end\r\n\t\tend = start\r\n\t\tstart = new_start\r\n\t}\r\n\tlet arr = range( start, end)\r\n\tif( exclude !== null)\r\n\t\tarr = arr.filter( n => !exclude.includes(n))\r\n\telse if( exclude_predicament)\r\n\t\tarr = arr.filter( n => !exclude_predicament( n))\r\n\r\n\tif( !arr.length){\r\n\t\tlog('err', 'conditions leave empty array')\r\n\t\tdebugger\r\n\t}\r\n\r\n\treturn pickRandomInArray( arr)\r\n}\r\n\r\nconst randomBags = {}\r\n\r\n/** so we can store in app and continue where we left off */\r\nexport const initRandomBag = (bag_id, bag) => {\r\n\tconsole.warn('INIT bag_id:', bag_id, bag.length)\r\n\trandomBags[ bag_id] = bag\r\n}\r\n\r\n/**\r\n * use or create a bag identified as (optional prefix + start + end)\r\n * create: bag is filled with a range() of numbers\r\n * use: picks (remove) a number at random; when empty bag is refilled\r\n */\r\nexport function randomNumberFromRangeBag( start, end, prefix='', initial_random_offset=false, return_bag=false, debug=false ){\r\n\t// if( debug) log('randomFromRangeBag:', start, end)\r\n\tconst bag_id = prefix + '_' + start + '_' + end // p_0_10\r\n\t// if( debug) log('check','bag_id:', bag_id)\r\n\tlet bag = randomBags[ bag_id]\r\n\t// bag &&\r\n\tif( !bag && initial_random_offset){\r\n\t\tbag = randomBags[ bag_id] = range( start, end, false)\r\n\t\tlet remove = randomNumberFromRange( 1, bag.length-1) /// should remain at least one\r\n\t\tfor( let i=0; i<remove; i++)\r\n\t\t\tbag.shift()\r\n\t\t//log('check', 'initial bag, removed:', remove)\r\n\t}\r\n\telse if( !bag || !bag.length)\r\n\t\tbag = randomBags[ bag_id] = range( start, end, false)\r\n\r\n\tconst index = Math.floor( Math.random() * bag.length)\r\n\r\n\t// if( debug) log('check','index:', index)\r\n\t//log('check', 'bag:', ...bag, 'picked:', bag[ index])\r\n\tconst val = bag.splice( index, 1)[0]\r\n\treturn return_bag ? [val,bag] : val\r\n}\r\n/// cols, rows = [...chances for each cols or rows]\r\nexport function getNumbersFor2DChances( cols, rows, bias=1, debug = false){\r\n\tconst grid = []\r\n\tconst instances = []\r\n\tlet highest = 0, lowest = 1000\r\n\r\n\tcols.forEach( (chances,col) => {\r\n\t\tfor( let i=0; i<10; i++)\r\n\t\t\tgrid.push( [i*10+col, chances])\r\n\t})\r\n\r\n\trows.forEach( (chances,row) => {\r\n\t\tfor( let i=0; i<10; i++){\r\n\t\t\tlet current = grid.find( num => num[0] === row*10+i)\r\n\t\t\tlet a = current[1],\r\n\t\t\t\t\tb = chances\r\n\t\t\tlet [lo,hi] = a<b ? [a,b] : [b,a]\r\n\t\t\tcurrent[1] = lo ? lo + ((hi-lo) * bias) : 0\r\n\t\t\tif( current[1] > highest)\r\n\t\t\t\thighest = current[1]\r\n\t\t\tif( current[1] > 0 && current[1] < lowest)\r\n\t\t\t\tlowest = current[1]\r\n\t\t}\r\n\t})\r\n\r\n\tconst has_range = lowest !== highest\r\n\tconst mult = 1//(bias*10)%2 ? 10 : 5 /// nums modified by bias of .2, .4, .6, .8 only need to be mult by 5 to get integer\r\n\tfor( let cell of grid){\r\n\t\tif( cell[1] > 0 && has_range){\r\n\t\t\t/// scale down to 1 so we don't end up with too many instances for nothing\r\n\t\t\tcell[1] = linearScaling( lowest, highest, 1, highest, cell[1])\r\n\t\t\t/// now we have precise but decimal num of chances; mult and round for imprecision\r\n\t\t\t/// so we'll have precision and integers, but a larger number of chances->instances\r\n\t\t\tcell[1] = Math.round( cell[1])\r\n\t\t}\r\n\t}\r\n\tgrid.sort( (a,b) => a[0]-b[0])\r\n\r\n\tif( debug)\r\n\tconsole.log( grid.map( n => n[0]+' -> '+n[1]).join('\\n'))\r\n\r\n\tfor( let [num,chances] of grid)\r\n\t\tfor( let i=0; i<chances; i++)\r\n\t\t\tinstances.push( num)\r\n\r\n\treturn instances\r\n}\r\n\r\nexport function chunksOfLength( arr, n){\r\n\treturn arr.reduce( (cumul, item, i) => {\r\n\t\tconst index = Math.floor( i/n)\r\n\t\tif( !cumul[ index]) cumul[ index] = []\r\n\t\tcumul[ index].push( item)\r\n\t\treturn cumul\r\n\t}, [])\r\n}\r\n\r\n\r\nexport function chunksForPropValues( arr, prop, values){\r\n\tlet chunks = []\r\n\tfor( let item of arr){\r\n\t\tlet val_index = values.indexOf( item[ prop])\r\n\t\tif( chunks[ val_index] === undefined)\r\n\t\t\tchunks[ val_index] = [item]\r\n\t\telse\r\n\t\t\tchunks[ val_index].push( item)\r\n\t}\r\n\treturn chunks\r\n}\r\n\r\nexport const fieldSorter = fields =>\r\n\t(a, b) => fields.map( o => {\r\n\t\tlet dir = 1\r\n\t\tif( o[0] === '-'){ dir = -1; o = o.substring(1) }\r\n\t\treturn a[o] > b[o] ? dir : a[o] < b[o] ? -(dir) : 0\r\n\t})\r\n\t.reduce( (p,n) => p ? p : n, 0)\r\n\r\n\r\n\r\n\r\n/**\r\n * find the col & row indices in a 2D Array (grid) by the index (position from top left) and the grid's number of column' (cols)\r\n * @param {number} index\r\n * @param {number} cols\r\n * @return {number[]} array of column and row coordinates\r\n */\r\nexport function getColRowByIndex( index, cols) {\r\n\tlet col = index % cols\r\n\tlet row = (index - index % cols) / cols\r\n\treturn [col, row]\r\n}\r\n/*\r\nexport const loadScript = (src, async=false) => new Promise( (resolve, reject) => {\r\n\t// console.warn('Load script:', src)\r\n\tlet s = document.createElement('script')\r\n\ts.onload = () => resolve( src)\r\n\ts.onerror = err => reject( err)\r\n\ts.async = async\r\n\tdocument.head.appendChild( s)\r\n\ts.src = src\r\n})\r\nexport const loadScripts = urls =>  urls.forEach( url => loadScript( url))\r\n */","const VERSION = '2023.01.09'\r\nconst COMPONENTS_DIR = '/_components/'\r\nconst CLEAR_STORE = false  //! Warning: erase all app data...\r\n\r\n//no-delay-fade-out\r\n\r\n/**\r\n * Vision Stage Framework\r\n * Stage to control aspect + rem scaling => total control of presentation / art direction\r\n * Native Web components\r\n * \t-> no build step! [lit-html template, easy insert locale strings, svg icons]\r\n * \t-> explicit render dependencies: this.uses([[comp, 'propX'], [comp, 'propY', 'propZ']])\r\n *  -> component instances are directly accessed / queried and modified without any limitations.\r\n *\t-> smart properties: self-renders on change: stored:true (for stringifyable values),\r\n *\t   watcher(val,prev){}, transformer(val,prev){return val}, class:'' (for bool - auto add/remove), attribute:'name' (mirrors value)\r\n * Old school: unscoped CSS & full reload (no hot module reloading)\r\n *\r\n */\r\n\r\nconst FONT_SIZE_DECIMALS = 0\r\nconst UPDATE_CHECK_MIN = 30\r\n// if = 1 : only one decimal => makes total rem space vary a bit,\r\n// but we get a more even layout spacing (Browsers are BAD at this)\r\n\r\n/// lit-html 1.4.1\r\n//! Bare imports: this is intended to be bundled w/ rollup (from node_modules)\r\nimport { html, svg, render as litRender }\r\n\tfrom 'lit-html/lit-html.js'\r\nimport { unsafeHTML }\r\n\tfrom 'lit-html/directives/unsafe-html.js'\r\nimport { ifDefined }\r\n\tfrom 'lit-html/directives/if-defined.js'\r\nimport { repeat }\r\n\tfrom 'lit-html/directives/repeat.js'\r\nimport { live }\r\n\tfrom 'lit-html/directives/live.js'\r\nimport { guard }\r\n\tfrom 'lit-html/directives/guard.js'\r\n\r\nimport { cache }\r\n\tfrom 'lit-html/directives/cache.js'\r\nimport { templateContent }\r\n\tfrom 'lit-html/directives/template-content.js'\r\n\r\n// z-console is kept out of the bundle by rollup externals option;\r\n// we need to import it as a blackboxed file in chrome TO GET REAL LINE NUMBERS in console!\r\nimport log from './z-console.js'\r\nlog('info',' Vision Stage ', VERSION, '(w/ lit-html 1.4.1)')\r\n\r\nimport { q, debounce, isObject, ctor, clone, loadStyleSheetAsync, objectFromString, containsHTML, nextFrame, cleanNum, is_iOS, is_safari, clamp, strIf  } from './utils-core.js'\r\n\r\n// Share with other components\r\n// export { log, q, qAll, html, svg, unsafeHTML, ifDefined, repeat, live, guard, templateContent, nextFrame, sleep, ctor, range, cache, tempClass, debounce, clamp, strIf, containsHTML }\r\n\r\nexport { log, html, svg, unsafeHTML, ifDefined, repeat, live, guard, cache }\r\n\r\nconst debug = {}\r\nlet app, store, store_namespace, after_resize_timeout, ASPECT_RATIOS\r\n\r\n// Will reference all components having an onResized method\r\n// to call them after window is resized\r\nconst resize_watchers = new Set()\r\n\r\nconst icons_mappings = {\r\n\tdelete: 'trash',\r\n\tremove: 'cross',\r\n\tadd: 'plus',\r\n\t// signs\r\n\t'+': 'plus',\r\n\t'x': 'cross'\r\n\r\n}\r\nconst icons_mappings_vb = {\r\n\t'double-chevron-right': '0 0 1024 1024',\r\n\t'arrow-right-rounded': '0 0 45.6 45.6',\r\n\t'fanion': '0 -11 100 120',\r\n}\r\n\r\n// keep track of the loaded ones, so we don't load the same component Class multiple times\r\nconst loaded_components = new Set()\r\n\r\n/// Component base class, to be extended by our components\r\nexport class Component extends HTMLElement {\r\n\r\n\tconstructor(){\r\n\t\t// Note: this (Component ctor) runs *after* VisionStage (app) ctor\r\n\t\tsuper()\r\n\t\tif( this.localName === 'vision-stage'){\r\n\t\t\tapp = this\r\n\t\t\tthis.id = 'app'\r\n\t\t\tthis.languages = ctor(this).languages\r\n\t\t\tconst path = decodeURI( location.pathname)\r\n\t\t\tthis.app_name =\r\n\t\t\tthis.ns = path.replace(/\\//g, '') || 'home'\r\n\t\t\t// log('info', 'app_name (for props local storage key):', this.ns)\r\n\t\t\tinitStore( this.ns)\r\n\t\t\tthis.buildCSSForLangs()\r\n\t\t}\r\n\t\tthis.#init()\r\n\r\n\t\t// default; changing app.lang updates ALL components\r\n\t\t// && this.strings ! some comp may use string from a .target\r\n\t\tif( this.localName !== 'vision-stage')\r\n\t\t\tthis.uses([['vision-stage', 'lang']])\r\n\t}\r\n\r\n\tconnectedCallback(){ // VisionStage overrides this\r\n\t\tthis.onConnected && this.onConnected()\r\n\t}\r\n\r\n\t#init(){\r\n\r\n\t\tconst _ctor = ctor( this)\r\n\t\tthis.is_component = true\r\n\t\tthis._state = {}\r\n\r\n\t\tlet properties\r\n\t\tif( _ctor.properties && _ctor._properties)\r\n\t\t\tproperties = Object.assign( {}, _ctor._properties, _ctor.properties)\r\n\t\telse\r\n\t\t\tproperties = _ctor.properties || _ctor._properties\r\n\r\n\t\t// to array of [key,val]\r\n\t\tlet flat_properties = properties ? Object.entries( properties) : []\r\n\r\n\t\tfor( let [prop, desc] of flat_properties) {\r\n\r\n\t\t\tif (!isObject( desc)) // wrap if primitive value\r\n\t\t\t\tdesc = { value: desc }\r\n\r\n\t\t\telse if (desc.storable && !this.id){\r\n\t\t\t\tlog('warn', 'trying to store:', prop, '...but no id on element (for store); ')\r\n\t\t\t\t// will use the tagName as the store key', '<'+this.tagName+'>','*** MAKE SURE THAT THIS ELEMENT IS ONLY USED ONCE ***')\r\n\t\t\t\t// throw Error('an element needs an id to be stored, tag:' + this.tagName)\r\n\t\t\t}\r\n\t\t\tlet store_id = this.id\r\n\t\t\tlet stored_val = !!store_id ? storedValue( store_id, prop) : undefined\r\n\t\t\tlet use_value = stored_val !== undefined ? stored_val : desc.value\r\n\t\t\tif( stored_val !== undefined){\r\n\t\t\t\tif( desc.storable)\r\n\t\t\t\t\tthis._state[ prop] = stored_val\r\n\t\t\t\telse //! DELETE / CLEAN UP\r\n\t\t\t\t\tsaveStore( store_id, prop, null, true)\r\n\t\t\t}\r\n\t\t\telse if( desc.storable) // store initial value\r\n\t\t\t\tsaveStore( store_id, prop, desc.value)\r\n\r\n\t\t\tif( desc.class)\r\n\t\t\t\tthis.classList.toggle( desc.class, !!use_value)\r\n\r\n\t\t\tif( desc.attribute){ // ['open', 'bool']\r\n\t\t\t\t//! wait for ctor to finish, else attr will be set to prop initial value before we read initial attr value\r\n\t\t\t\trequestAnimationFrame( t => {\r\n\r\n\t\t\t\t\tif( typeof desc.attribute === 'string'){\r\n\t\t\t\t\t\tthis.setAttribute( desc.attribute, use_value)\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse { // Array\r\n\t\t\t\t\t\tlet attr = desc.attribute[0]\r\n\t\t\t\t\t\t// remove if falsy value, otherwise set to empty value (\"\")\r\n\t\t\t\t\t\tif( desc.attribute[1] === 'bool'){\r\n\t\t\t\t\t\t\tif( !use_value) // falsy; remove\r\n\t\t\t\t\t\t\t\tthis.removeAttribute( attr)\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tthis.setAttribute( attr, '')\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// set to a truthy value, otherwise remove\r\n\t\t\t\t\t\telse if( desc.attribute[1] === 'auto'){\r\n\t\t\t\t\t\t\tif( !use_value) // falsy; remove\r\n\t\t\t\t\t\t\t\tthis.removeAttribute( attr)\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tthis.setAttribute( attr, use_value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tthrow 'Unknown attribute type'\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t})\r\n\t\t\t}\r\n\r\n\t\t\tObject.defineProperty( this, prop, {\r\n\t\t\t\tget(){\r\n\t\t\t\t\t// log('info','GET', prop, '=>', this._state[ prop] )\r\n\t\t\t\t\t// can use a getter on desc for computed prop\r\n\t\t\t\t\treturn desc.getter ? desc.getter.call( this, this._state[ prop]) : this._state[ prop]\r\n\t\t\t\t},\r\n\t\t\t\tset( val){ /// SET:\r\n\t\t\t\t\t// log('pink', 'SET prop:', this.id, prop, val)\r\n\t\t\t\t\tlet store_id = this.id\r\n\t\t\t\t\tif( desc.storable && !store_id)\r\n\t\t\t\t\t\tlog('err', 'no store id for prop:', prop, this)\r\n\r\n\r\n\t\t\t\t\tif( prop in properties){ //// in? ==> is a reactive prop\r\n\t\t\t\t\t\tlet no_render = false\r\n\t\t\t\t\t\tlet prev_val = this._state[ prop]\r\n\t\t\t\t\t\tlet t_val\r\n\t\t\t\t\t\tif( desc.transformer && !this.bypass_transformer)\r\n\t\t\t\t\t\t\tt_val = desc.transformer.call( this, val, prev_val, desc.value, stored_val)\r\n\r\n\t\t\t\t\t\tlet force_render = desc.force_render\r\n\r\n\t\t\t\t\t\t// do not return -> WE MAY STILL NEED WATCHER FOR SIDE EFFECTS\r\n\t\t\t\t\t\tif( val===prev_val && !force_render || t_val === 'cancel' /* MAGIC WORD :| */)\r\n\t\t\t\t\t\t\tno_render = true\r\n\r\n\r\n\t\t\t\t\t\tif( t_val !== undefined)\r\n\t\t\t\t\t\t\tval = t_val\r\n\r\n\t\t\t\t\t\tif( desc.storable){\r\n\t\t\t\t\t\t\t// throttled_saveStore will only be fired once \r\n\t\t\t\t\t\t\t// though it may be called again with different params...\r\n\t\t\t\t\t\t\t// like rx and ry during a continuous dragging,\r\n\t\t\t\t\t\t\t// then only one of them would be stored in the end\r\n\t\t\t\t\t\t\t// so store value here directly and leave the global\r\n\t\t\t\t\t\t\t// localstorage saving for the throttled callback\r\n\t\t\t\t\t\t\tstore[ store_id] ||= {}\r\n\t\t\t\t\t\t\tstore[ store_id][ prop] = val\r\n\t\t\t\t\t\t\tthrottled_saveStore() /// global store (will be called at least once after multiple set)\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tthis._state[ prop] = val\r\n\r\n\t\t\t\t\t\tif( !this.block_watcher){\r\n\t\t\t\t\t\t\t//this.id==='app' && log('pink', 'calling watcher...')\r\n\t\t\t\t\t\t\tdesc.watcher && desc.watcher.call( this, val, prev_val)\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif( desc.attribute){ /// ['open', 'bool']\r\n\t\t\t\t\t\t\tif( typeof desc.attribute === 'string'){\r\n\t\t\t\t\t\t\t\tthis.setAttribute( desc.attribute, val)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse { // Array\r\n\t\t\t\t\t\t\t\tlet attr = desc.attribute[0]\r\n\t\t\t\t\t\t\t\t// remove if falsy value, otherwise set to empty value (\"\")\r\n\t\t\t\t\t\t\t\tif( desc.attribute[1] === 'bool'){\r\n\t\t\t\t\t\t\t\t\tif( !use_value) // falsy; remove\r\n\t\t\t\t\t\t\t\t\t\tthis.removeAttribute( attr)\r\n\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\tthis.setAttribute( attr, '')\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t// set to a truthy value, otherwise remove\r\n\t\t\t\t\t\t\t\telse if( desc.attribute[1] === 'auto'){\r\n\t\t\t\t\t\t\t\t\tif( !val) // falsy; remove\r\n\t\t\t\t\t\t\t\t\t\tthis.removeAttribute( attr)\r\n\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\tthis.setAttribute( attr, val)\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\tthrow 'Unknown attribute type'\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif( desc.class)\r\n\t\t\t\t\t\t\tthis.classList.toggle( desc.class, !!val)\r\n\r\n\t\t\t\t\t\tif( desc.reactive !== false && !no_render)\r\n\t\t\t\t\t\t\tthis.render()\r\n\r\n\r\n\t\t\t\t\t\t//if( debug.renders && this.renders) log('err','this, renders:', prop, this.renders, this.renders.get( prop))\r\n\r\n\t\t\t\t\t\t// take care of dependencies ( this.uses([target,propA,propB]) )\r\n\t\t\t\t\t\tif( this.renders && this.renders.has( prop)){\r\n\t\t\t\t\t\t\trequestAnimationFrame( e => {\r\n\t\t\t\t\t\t\t\tfor( let render_target of this.renders.get( prop)){\r\n\t\t\t\t\t\t\t\t\tif( debug.renders) log('check', 'prop, render target:', prop, render_target)\r\n\t\t\t\t\t\t\t\t\trender_target.render()\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tlog('err','NO own prop on this:', prop, properties)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t})\r\n\r\n\t\t\tif( desc.init_watcher===true){\r\n\t\t\t\t//! should not cause render; call manually\r\n\t\t\t\t// log('check', 'init_watcher true; prop:', prop)\r\n\t\t\t\tlet prev_val = this._state[ prop]\r\n\t\t\t\tthis._state[ prop] = use_value\r\n\t\t\t\tdesc.watcher && desc.watcher.call( this, use_value, prev_val)\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// init \"silently\": no watcher/transformer etc...\r\n\t\t\t\tthis._state[ prop] = use_value\r\n\t\t\t\tif( desc.init_watcher==='onRendered'){\r\n\t\t\t\t\tthis.setOnRendered = [prop, use_value]\r\n\t\t\t\t}\r\n\t\t\t\telse if( desc.init_watcher === 'deferred'){\r\n\t\t\t\t\tsetTimeout( () => {\r\n\t\t\t\t\t\tthis[ prop] = use_value\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//! We should only clone once and store on another static prop...\r\n\t\t//! in case there's many instances...\r\n\t\tconst strings = (_ctor.strings ? clone( _ctor.strings) : {})\r\n\r\n\t\tif( _ctor._strings)\r\n\t\t\tObject.assign( strings, _ctor._strings)\r\n\r\n\t\t// removed : attribute strings\r\n\r\n\t\tif( _ctor.strings){\r\n\t\t\tif( !app.languages)\r\n\t\t\t\tlog('err', 'no app languages yet', this)\r\n\r\n\t\t\tthis.strings = strings\r\n\r\n\t\t\t// this.$name -> getters for strings\r\n\t\t\tfor( let name in strings){\r\n\t\t\t\tObject.defineProperty( this, '$'+name, {\r\n\t\t\t\t\tget(){ return this.getString( name) },\r\n\t\t\t\t\tset(){ throw 'cannot set a string' }\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif( this.onResized && !resize_watchers.has( this)){\r\n\t\t\tresize_watchers.add( this)\r\n\t\t\t//log('check', 'resize_watchers\t:', resize_watchers)\r\n\t\t}\r\n\r\n\t\tif( _ctor.attributes){\r\n\t\t\tfor( let attr of _ctor.attributes){\r\n\t\t\t\tthis[ attr] = this.getAttribute( attr)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif( _ctor.sounds)\r\n\t\t\tapp.sounds_list = _ctor.sounds\r\n\t}\r\n\r\n\t/**\r\n\t * Declares that a component uses one or more props from another component\r\n\t * and must also be rendered when this other component's prop changes.\r\n\t */\r\n\tuses( entries){\r\n\t\t//log('pink', 'this, uses:', this, entries)\r\n\t\t//\r\n\t\t// -> for each target:  target.renders = Map([['prop1', Set.add(this)],[prop2, Set.add(this)]])\r\n\t\t// \t\t\t\t\t\t\t\t\t\t\tapp.renders = Map([['lang', ADD this]])\r\n\t\tfor( let entry of entries){\r\n\t\t\t/// non destructive...\r\n\t\t\tlet prop_holder = entry[0]\r\n\t\t\tlet props = entry.slice(1) /// copy the rest\r\n\t\t\t// if( props.length > 1) /// 1 => only lang\r\n\t\t\t//! @TODO only `uses` lang when a comp actually uses lang ?\r\n\t\t\t//! -> check for: 1. [lang] attr and 2. strings is not empty\r\n\t\t\tif( debug.uses && props.length){\r\n\t\t\t\tlog('info', '<'+(this.id||this.tagName+'::'+this.className)+'>', 'will render when any of [',...props,'] on', '<'+prop_holder+'>', 'is set')\r\n\t\t\t}\r\n\r\n\t\t\tif( typeof prop_holder === 'string'){\r\n\t\t\t\tlet prop_holder_selector = prop_holder\r\n\t\t\t\tprop_holder = q( prop_holder_selector)\r\n\t\t\t\tif( !prop_holder)\r\n\t\t\t\t\tthrow 'uses(); prop_holder do not exist (yet?): ' + prop_holder_selector\r\n\t\t\t\t\t//debugger\r\n\t\t\t}\r\n\t\t\tif( !prop_holder) {\r\n\t\t\t\tlog('err', 'no prop holder, entry:', entry)\r\n\t\t\t\tlog('info', '<'+(this.id||this.tagName+'::'+this.className)+'>', 'will render when any of [',...props,'] on', '<'+prop_holder+'>', 'is set')\r\n\t\t\t\tdebugger\r\n\t\t\t}\r\n\t\t\tprop_holder.renders = prop_holder.renders || new Map()\r\n\r\n\t\t\tfor( let prop of props){\r\n\t\t\t\tif( prop_holder.renders.has( prop)) /// value exist (Set of render targets)\r\n\t\t\t\t\tprop_holder.renders.get( prop).add( this)\r\n\t\t\t\telse\r\n\t\t\t\t\tprop_holder.renders.set( prop, new Set([this]))\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/** sets the state without triggering render or watcher/transformer */\r\n\tsetState( name, value){ this._state[ name] = value }\r\n\r\n\t/** set an attribute and render this */\r\n\tsetAttr( name, value){\r\n\t\tthis.setAttribute( name, value)\r\n\t\tthis.render()\r\n\t}\r\n\r\n\t/**\r\n\t * Component render function\r\n\t * @param evt_ctx {Component} We may use another component as the events context (so `this` will refer to this other component instead of the one where the handler is defined).\r\n\t */\r\n\tasync render( evt_ctx){\r\n\t\tif( !this.template){\r\n\t\t\tif( this.localName !== 'vision-stage')\r\n\t\t\t\tlog('warn', '--no template, cannot render(): '+ this.id +', '+ this.tagName)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tconst debugging = debug.render===true ||\r\n\t\t\tArray.isArray( debug.render) && debug.render.includes( this.id||this.classList[0])\r\n\r\n\t\tif( !this.needsRender){\r\n\t\t\tthis.needsRender = true\r\n\t\t\t// debugging && log('warn', 'needsd render:', this.id)\r\n\r\n\t\t\tawait nextFrame()\r\n\r\n\t\t\t!this.rendered && this.beforeFirstRender && this.beforeFirstRender()\r\n\r\n\t\t\tif( this.beforeRender && this.beforeRender()===false){\r\n\t\t\t\tlog('err', 'Aborted render for:', this.id)\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\r\n\t\t\tthis.needsRender = false\r\n\t\t\tconst tmpl = this.template()\r\n\t\t\t//! => we might return null if something is missing for rendering the template\r\n\t\t\tif( !tmpl){ // === null){\r\n\t\t\t\tif( debugging)\r\n\t\t\t\t\tlog('err', '--tmpl: no value -> no render', this.id, this.localName)\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\r\n\t\t\tif( debugging)\r\n\t\t\t\tlog('gold','--GOT TMPL, RENDER ', (this.id||this.classList[0]))\r\n\r\n\t\t\t// log('warn', 'eventContext: this:', this)\r\n\t\t\t// log('info', 'rendering', this.id || this.localName)\r\n\t\t\tlitRender( tmpl, this, {\r\n\t\t\t\tscopeName: this.localName,\r\n\t\t\t\teventContext: evt_ctx || this.event_context || this\r\n\t\t\t})\r\n\r\n\t\t\tconst has_been_rendered = this.rendered\r\n\t\t\tthis.rendered = true //! BEFORE CALLBACK TO PREVENT IFINITE LOOP\r\n\t\t\tif( !has_been_rendered){\r\n\t\t\t\tthis._onFirstRendered && this._onFirstRendered()\r\n\t\t\t\tthis.onFirstRendered && this.onFirstRendered()\r\n\t\t\t\tif( this.skipped_onResized){\r\n\t\t\t\t\tthis.skipped_onResized = false\r\n\t\t\t\t\tthis.onResized( ...this.skipped_params)\r\n\t\t\t\t\tthis.skipped_params = null\r\n\t\t\t\t}\r\n\t\t\t\t//-- delete this.onFirstRendered\r\n\t\t\t\t// -> it's supposedly better not to delete anything after an object definition\r\n\t\t\t}\r\n\t\t\tthis._onRendered && this._onRendered()\r\n\t\t\tthis.onRendered && this.onRendered()\r\n\t\t\tif( this.setOnRendered){\r\n\t\t\t\tlet [prop,val] = this.setOnRendered\r\n\t\t\t\tthis[ prop] = val\r\n\t\t\t\tthis.setOnRendered = null\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if( debugging)\r\n\t\t\tlog('gold','already needsRender, waiting:', (this.id||this.classList[0]))\r\n\t}\r\n\r\n\t/**\r\n\t * this.querySelector shorthand.\r\n\t * @param sel {string} CSS selector string\r\n\t * @return {Array<HTMLElement>}\r\n\t */\r\n\tq( sel){\r\n\t\treturn this.querySelector( sel)\r\n\t}\r\n\r\n\t/**\r\n\t * this.querySelectorAll shorthand  Query elements and transform to an array.\r\n\t * @param sel {string} CSS selector string\r\n\t * @return {HTMLElement}\r\n\t */\r\n\tqAll( sel){\r\n\t\treturn Array.from( this.querySelectorAll( sel))\r\n\t}\r\n\r\n\t/**\r\n\t * Method automatically called by generated string getters using the syntax: this.$welcome\r\n\t * ! warning: will return result of unsafeHTML if contains HTML (looks for <tag> or HTML entity),\r\n\t * ! use raw=true argument if we need the raw HTML string to use outside a lit-html template,\r\n\t * ! like in a prop binding: <div .html_str=${ getString() } or when directly setting .innerHTML\r\n\t * @param str_name {string} The name for the requested string.\r\n\t * @param raw {bool} If we should return the raw string for a string containing HTML instead of the result of unsafeHTML.\r\n\t * @return the string corresponding to the actual language\r\n\t */\r\n\tgetString( str_name, raw=false){\r\n\t\tif( !str_name) return ''\r\n\t\tif( !this.strings[ str_name]){\r\n\t\t\tlog('warn','NO STRING FOUND FOR:', str_name)\r\n\t\t\treturn ''\r\n\t\t}\r\n\t\tlet lang = (app || this).lang\r\n\t\tlet lang_index = this.languages.indexOf( lang)\r\n\t\tlet str = this.strings[ str_name][ lang_index] || this.strings[ str_name][0]\r\n\t\treturn raw ? str : // force 'as is' even if contains html\r\n\t\t\tcontainsHTML( str) ? unsafeHTML( str) : // detected html\r\n\t\t\tstr.startsWith('>') ? unsafeHTML( str.slice(1)) : // explicit html\r\n\t\t\tstr // as is\r\n\t}\r\n\r\n\t/** Toggle between two classes based on a condition */\r\n\tswitchClasses( a, b, condition){\r\n\t\tthis.classList.toggle(a, condition)\r\n\t\tthis.classList.toggle(b, !condition)\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an array from an attribute value consisting of\r\n\t * space or comma (w/ possible spaces around) separated strings.\r\n\t * @param name {string} Name of the attribute whose value is to parse.\r\n\t * @param alt {string} A possible alternate attribute name if first is not declared.\r\n\t * @return {array<string>}\r\n\t */\r\n\tgetAttributeList( name, alt){\r\n\t\t// log('pink', 'attr list from:', name)\r\n\t\treturn (this.getAttribute( name)||this.getAttribute( alt)).split(/\\s*[,\\s]\\s*/)\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an array for a string consisting of\r\n\t * space or comma (w/ possible spaces around) separated strings.\r\n\t * @param str {string} The string to parse.\r\n\t * @return {array<string>}\r\n\t */\r\n\tgetStringList( str){\r\n\t\treturn str.split(/\\s*[,\\s]\\s*/)\r\n\t}\r\n\r\n\t/**\r\n\t * Load a component JS and CSS files dynamically,\r\n\t * either from the `/_components/` dir if bare path,\r\n\t * or relative to app dir if path starts with `./`\r\n\t * or absolutely if path starts with `/`\r\n\t * @param file_path {string} Path for component\r\n\t * @return {Promise<ModuleNamespaceObject>} an object that describes all exports from a module\r\n\t */\r\n\tstatic async load( file_path, scripts){\r\n\t\tif( debug.load)\r\n\t\t\tlog('ok','load() file_path:', file_path)\r\n\r\n\t\t// first check if already loaded\r\n\t\tif( loaded_components.has( file_path)){\r\n\t\t\t//log('info', 'component already loaded:', file_path)\r\n\t\t\treturn\r\n\t\t}\r\n\t\telse\r\n\t\t\tloaded_components.add( file_path)\r\n\r\n\t\t/*if( scripts){\r\n\t\t\tscripts = scripts.split(/\\s*,?\\s/)\r\n\t\t\t\t.map( src => loadScriptAsync( src.includes('/') ? src : `/scripts/${src}`))\r\n\t\t\tawait Promise.all( scripts)\r\n\t\t}*/\r\n\r\n\t\tlet js, css\r\n\t\tif( Array.isArray( file_path)){\r\n\t\t\tjs = file_path[0] + '.js'\r\n\t\t\tcss = file_path[1] + '.css'\r\n\t\t}\r\n\t\telse if( file_path.endsWith('.js')){\r\n\t\t\tjs = file_path\r\n\t\t}\r\n\t\telse { // normal: extensionless => same for both\r\n\t\t\tjs = file_path + '.js'\r\n\t\t\tcss = file_path/* .replace('.min','') */ + '.css'\r\n\t\t}\r\n\r\n\t\t// if starts with ./ -> remove and use pathname, else assume is in /_components/\r\n\t\t// unless abs (/) -> then leave as is\r\n\t\tif (/^\\./.test( css))\r\n\t\t\tcss = location.pathname + css.replace(/^\\.\\//,'') // if starts with dot, remove it\r\n\t\telse if (! /^\\./.test( css))\r\n\t\t\tcss = `${ DIRECTORY + COMPONENTS_DIR }${ css }`\r\n\r\n\t\tif (/^\\./.test( js))\r\n\t\t\tjs = location.pathname + js.replace(/^\\.\\//,'') // if starts with dot, remove it\r\n\t\telse\r\n\t\t\tjs = `${ DIRECTORY + COMPONENTS_DIR }${ js }`\r\n\r\n\t\tif (debug.load)\r\n\t\t\tlog('purple', 'load js, css :', js, css)\r\n\t\t// make sure CSS is loaded before we import js so no flash of unstyled components\r\n\t\tcss && await loadStyleSheetAsync( css)\r\n\t\treturn import( js)\r\n\t}\r\n\r\n\tstatic loadAll( ...components){\r\n\t\tcomponents = components.map( c => Component.load( c))\r\n\t\treturn Promise.all( components)\r\n\t}\r\n}\r\n\r\n\r\nlet active_sw, redundant\r\n\r\n// App Component\r\nexport class VisionStage extends Component {\r\n\r\n\tconstructor(){\r\n\t\tsuper()\r\n\t\tthis.lang = this.lang // trigger watcher now\r\n\r\n\t\t// -> disable right-clicking\r\n\t\t// this.addEventListener( 'contextmenu', e => e.preventDefault())\r\n\r\n\t\tthis.is_iOS = is_iOS\r\n\t\tthis.scrolls = this.classList.contains('scroll')\r\n\r\n\t\t// Save store to localStorage on pagehide / unload\r\n\t\tif( !CLEAR_STORE){\r\n\t\t\tconst termination_event = 'onpagehide' in self ? 'pagehide' : 'unload';\r\n\t\t\twindow.addEventListener( termination_event, e => saveStore())\r\n\t\t}\r\n\r\n\t\t// auto filled by each component\r\n\t\tthis.foldable_components = new Set()\r\n\r\n\t\t// add 'using-mouse' class which hides input outlines\r\n\t\t// fold all <vs-selector> components\r\n\t\tdocument.body.addEventListener('pointerdown', (e) => {\r\n\r\n\t\t\tdocument.body.classList.add('using-mouse')\r\n\r\n\t\t\t// means we clicked on a vs-selector component, leave it manage clicks\r\n\t\t\tif (e.target.closest('vs-selector[folds]'))\r\n\t\t\t\treturn\r\n\r\n\t\t\t// else we clicked something else, close all <vs-selector>\r\n\t\t\tfor (let sel_btn of this.foldable_components)\r\n\t\t\t\tif (!sel_btn.folded) sel_btn.folded = true\r\n\t\t})\r\n\r\n\t\t// remove 'using-mouse' class which hides input outlines\r\n\t\tdocument.body.addEventListener('keydown', (e) => {\r\n\t\t\tif (!e.key) return // -> autofill\r\n\t\t\tdocument.body.classList.remove('using-mouse')\r\n\t\t})\r\n\r\n\t\twindow.addEventListener('hashchange', this.#onHashChanged.bind( this))\r\n\t\tthis.updateAspect( ctor( this).aspects)\r\n\r\n\t\tthis._onInstallable = this.onInstallable.bind( this)\r\n\t\tthis._onInstalled = this.onInstalled.bind( this)\r\n\r\n\t\twindow.addEventListener('beforeinstallprompt', this._onInstallable)\r\n\t\twindow.addEventListener('appinstalled', () => this._onInstalled)\r\n\t}\r\n\r\n\tasync onInstallable (e){\r\n\t\t// Prevent the mini-infobar from appearing on mobile\r\n\t\te.preventDefault()\r\n\t\t// Stash the event so it can be triggered later.\r\n\t\tthis.deferredPrompt = e\r\n\t\t// Update UI notify the user they can install the PWA\r\n\t\t// ...showInstallPromotion()\r\n\t\tlog('ok','App is installable')\r\n\t\tthis.classList.add('installable') /// use to show install shortcut/standalone button\r\n\t}\r\n\r\n\t/** user want to \"install\" a shortcut, trigger native prompt */\r\n\tinstall (e){\r\n\t\tif( !this.deferredPrompt){\r\n\t\t\tlog('err','no deferredPrompt', this)\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tthis.deferredPrompt.prompt() // native prompt\r\n\t\t// this.deferredPrompt.userChoice\r\n\t\t// \t.then( choiceResult => {\r\n\t\t// \t\tif( choiceResult.outcome === 'accepted')\r\n\t\t// \t\t\t// hides install section in menu\r\n\t\t// \t\t\tthis.classList.remove('installable')\r\n\t\t// \t\t// else user dismissed prompt\r\n\t\t// \t\tthis.deferredPrompt = null\r\n\t\t// \t})\r\n\t}\r\n\r\n\tonInstalled (e){\r\n\t\tlog('ok', 'App installed')\r\n\t\tthis.deferredPrompt = null\r\n\t\tthis.classList.remove('installable')\r\n\t\t// Note: app only mount once, thus classes can be managed procedurally\r\n\t}\r\n\r\n\tconnectedCallback (){\r\n\r\n\t\t// this.classList.add('fade-in')\r\n\t\tthis.onConnected && this.onConnected()\r\n\t\t// no pages yet\r\n\t\tif( this.$doc_title){\r\n\t\t\tdocument.title = this.$doc_title + '  ' + decodeURI( location.hash.slice(1))\r\n\t\t}\r\n\t\t// else: title remain as defined in the <title> tag\r\n\r\n\t\tif( ctor( this).sounds)\r\n\t\t\tthis.setupSounds() // playSound( name), stopSound( name)\r\n\r\n\t\t// this.registerSW()\r\n\t}\r\n\r\n\t#onHashChanged (e){\r\n\t\tthis.#setPageFromHash()\r\n\t}\r\n\r\n\t#setPageFromHash (){ // sets this.page name (coresp to [page] attribute)\r\n\t\tlet h = decodeURI( location.hash.slice(1))\r\n\t\tif (!h){\r\n\t\t\tif( this.page !== '')\r\n\t\t\t\tthis.page = ''\r\n\t\t\tif( this.$doc_title)\r\n\t\t\t\tdocument.title = this.$doc_title\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// find corresp. path in pages to get key\r\n\t\tlet [page, ...params] = h.split('/')\r\n\t\t// page:pA=1,p2=allo\r\n\t\tthis.params = !params ? [] : params\r\n\t\t\t.map( p => p.split('='))\r\n\t\t\t.map( ([k,v]) => [k, v==='true'?true : v==='false'?false : !isNaN(v)?parseFloat(v) : v])\r\n\r\n\t\tlet page_name = ''\r\n\t\touter:\r\n\t\tfor (let [name, data] of this.pages){\r\n\t\t\tfor (let lang in data){\r\n\t\t\t\tif (data[ lang].path === page){\r\n\t\t\t\t\tpage_name = name\r\n\t\t\t\t\tbreak outer\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!page_name){ // unknown\r\n\t\t\tlog('err', 'unknown path:', h)\r\n\t\t\tthis.page = ''\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tthis.page = page_name\r\n\r\n\t\tlet {path, title} = this.getPage()\r\n\t\tif (this.$doc_title)\r\n\t\t\tdocument.title = this.$doc_title + '  ' + title\r\n\t}\r\n\r\n\t/**\r\n\t * gets the page sub-object {title,path} for the current lang\r\n\t */\r\n\tgetPage (page_name=null){\r\n\r\n\t\tif (!this.pages){\r\n\t\t\tlog('warn', 'no pages yet')\r\n\t\t\treturn null\r\n\t\t}\r\n\t\tlet p_name = (page_name===null ? this.page : page_name)\r\n\t\tlet page = this.pages.find( ([name]) => p_name === name)\r\n\t\tlet lang = this.lang\r\n\t\tif( page && !page[1][lang])\r\n\t\t\tthrow 'Missing string for page with current lang: ' + p_name + ' -> ' + lang\r\n\r\n\t\treturn page ? page[1][lang] : {} // [1] == data\r\n\t}\r\n\r\n\tpageLink( page, postfix='', clss=''){\r\n\t\tif( !this.pages) return ''\r\n\t\t//log('check', 'page link:', page)\r\n\t\tlet pre = page.startsWith('/') ? '/' : './#'\r\n\t\tlet p = this.getPage( page)\r\n\t\tif( pre === '/'){\r\n\t\t\tp.path = page.slice(1)\r\n\t\t}\r\n\t\t//let clss = btn ? ' button' : ''\r\n\t\treturn postfix ?\r\n\t\t\thtml`<a class=${ strIf('selected', page === this.page)}\r\n\t\t\t\thref='${ pre }${ page ? p.path : '' }'>${ p.title }</a><span class='nav-sep'>${ postfix }</span>`\r\n\t\t\t:\r\n\t\t\thtml`<a class=${strIf('selected', page === this.page) + ' ' + clss}\r\n\t\t\t\thref='${ pre }${ page ? p.path : '' }'>${ p.title }</a>`\r\n\t}\r\n\r\n\t_onFirstRendered(){\r\n\r\n\t\tlet pages = ctor( this).pages\r\n\t\tif (pages){\r\n\t\t\t// map each title to {title, path} (path is title with spaces replaced by -)\r\n\t\t\tthis.pages = Object.entries( pages).map(([name, titles]) => {\r\n\t\t\t\tlet obj = {}\r\n\t\t\t\tlet lang_index = 0\r\n\t\t\t\tfor( let title of titles){\r\n\t\t\t\t\tlet lang = this.languages[ lang_index++]\r\n\t\t\t\t\tobj[ lang] = { title, path: title.replace(/\\s/g, '-') }\r\n\t\t\t\t}\r\n\t\t\t\treturn [name, obj]\r\n\t\t\t})\r\n\t\t}\r\n\t\tthis.#setPageFromHash()\r\n\t}\r\n\r\n\t// Scrolled detection for setting different styles\r\n\t// onMainScroll(e){\r\n\t// \tthis.classList.toggle('scrolled', main.scrollTop > 10)\r\n\t// }\r\n\r\n\tafterResize (e){\r\n\t\tapp.resizing = false\r\n\t\tapp.updateScrollbarClass()\r\n\t}\r\n\r\n\t_onRendered (){\r\n\t\tlet main = this.q('main')\r\n\t\tif( main) this.main = main\r\n\t\tthis.updateScrollbarClass()\r\n\t}\r\n\r\n\t//!! unreliable: this.main.scrollHeight > this.main.offsetHeight is often true when no scrollbar\r\n\t/** sets .main-has-scrollbar for app-header/footer shadows */\r\n\tupdateScrollbarClass (){\r\n\t\t// log('pink', 'update scrollbar class')\r\n\t\tif( this.main && this.main.classList.contains('scroll')){\r\n\t\t\tlet has = this.main.scrollHeight > this.main.offsetHeight\r\n\t\t\tthis.classList.toggle('main-has-scrollbar', has)\r\n\t\t\t//if( has) log('check', 'main has scrollbar; scroll height, main height:', this.main.scrollHeight, this.main.offsetHeight)\r\n\t\t}\r\n\t\t// else {\r\n\t\t// \tlog('err', 'no main')\r\n\t\t// }\r\n\t}\r\n\r\n\tresize (){\r\n\t\tif( this.resize_locked)\r\n\t\t\treturn // mobile + menu auth open -> prevent resize by onscreen keyboard\r\n\r\n\t\tthis.resizing = true\r\n\t\tclearTimeout( after_resize_timeout)\r\n\t\tafter_resize_timeout = setTimeout( this.afterResize, 1000)\r\n\r\n\t\t//tempClass( this, 'resizing', 1) //! tempClass doesn't reset its timeout...\r\n\t\tconst threshold = ASPECT_RATIOS.threshold\r\n\t\tconst root = document.documentElement\r\n\t\tconst FSD = this.font_size_decimals || FONT_SIZE_DECIMALS\r\n\t\t//log('check', 'FSD:', FSD)\r\n\t\tlet w = window.innerWidth,\r\n\t\t\t h = window.innerHeight\r\n\t\tconst AR = { now: parseFloat( cleanNum( w / h)), min: 0 }\r\n\r\n\t\t// true also if we specify only portrait\r\n\t\tconst is_portrait = (ASPECT_RATIOS.portrait && AR.now < threshold) || !ASPECT_RATIOS.landscape\r\n\r\n\t\t//if( this.is_portrait !== is_portrait)\r\n\t\tthis.is_portrait = is_portrait\r\n\r\n\t\t// defines what relative height we want (in rem)\r\n\t\tlet height_rem = // ASPECT_RATIOS.height ||\r\n\t\t\tthis.is_portrait\r\n\t\t\t\t? (ASPECT_RATIOS.portrait_height || ASPECT_RATIOS.height || 40)\r\n\t\t\t\t: (ASPECT_RATIOS.landscape_height || ASPECT_RATIOS.height || 40)\r\n\t\t// log('warn', 'rem height:', height_rem)\r\n\t\tif( this.is_portrait){\r\n\t\t\tAR.min = ASPECT_RATIOS.portrait_min\r\n\t\t\tAR.base = ASPECT_RATIOS.portrait\r\n\t\t\tAR.max = ASPECT_RATIOS.portrait_max\r\n\t\t\tAR.tall = AR.base\r\n\t\t}\r\n\t\telse {\r\n\t\t\tAR.min =\r\n\t\t\tAR.base = ASPECT_RATIOS.landscape||1.6\r\n\t\t\tAR.max = ASPECT_RATIOS.landscape_max||11 \t// 0 = 11 => virtually no limit\r\n\t\t\tAR.wide = AR.base\r\n\t\t}\r\n\r\n\t\tlet margin = 0,\r\n\t\t\tabove_landscape_max = AR.now > AR.max,\r\n\t\t\tbelow_landscape = AR.now < AR.base\r\n\r\n\t\tconst cm = ASPECT_RATIOS.cross_margin\r\n\r\n\t\tif( !this.is_portrait)\r\n\t\t\tmargin = (above_landscape_max || below_landscape) ? cm : 0\r\n\t\t// just below threshold, above portrait max -> side \"black bars\"\r\n\t\telse if( cm && AR.now > AR.max)\r\n\t\t\tmargin = cm\r\n\r\n\t\tthis.setAttribute('orientation', this.is_portrait ? 'portrait' : 'landscape')\r\n\t\tlet ar = AR.now\r\n\t\tlet asp =\r\n\t\t\tar < ASPECT_RATIOS.portrait \t\t? 'portrait-min'\t: // below portrait\r\n\t\t\tar < ASPECT_RATIOS.portrait_max \t? 'portrait-mid'\t: // between portrait & portrait_max\r\n\t\t\tar < ASPECT_RATIOS.threshold \t\t? 'portrait-max'\t: // between portrait_max & threshold\r\n\t\t\tar < ASPECT_RATIOS.landscape \t\t? 'landscape-min'\t: // between threshold & landscape\r\n\t\t\tar < ASPECT_RATIOS.landscape_max ? 'landscape-mid'\t: // between landscape and landscape_max\r\n\t\t\t'landscape-max' // above landscape_max\r\n\t\tthis.setAttribute('aspect-range', asp)\r\n\r\n\t\tif( typeof margin === 'string') // assumes %, implicit or explicit\r\n\t\t\tmargin = parseFloat(margin) * h / 100\r\n\r\n\t\t// Adjust size for margin\r\n\t\tif( AR.now > AR.max){\r\n\t\t\tif( margin)\r\n\t\t\t\th -= (margin * 2)\r\n\t\t\tw = Math.floor( h * AR.max) // smallest of: window width or max AR\r\n\t\t}\r\n\t\telse if( AR.base && AR.now < AR.base){ // was (AR.base||AR.min) ?\r\n\t\t\tif( margin)\r\n\t\t\t\tw -= margin * 2\r\n\t\t\t// if( this.margin)\r\n\t\t\t// \th -= margin * 2\r\n\t\t\t// cap height (h) to base AR\r\n\t\t\tconst MIN_AR = 1 / (AR.wide || AR.min)\r\n\t\t\th = Math.floor( Math.min( w * MIN_AR, h)) // smallest of: window height (h) or base AR\r\n\t\t}\r\n\t\t// else if( this.margin){\r\n\t\t// \tw -= margin * 2\r\n\t\t// \th -= margin * 2\r\n\t\t// }\r\n\t\tthis.classList.toggle('has-margins', !!margin)\r\n\r\n\t\tthis.sth = h\r\n\t\tthis.stw = w\r\n\t\tthis.AR = w/h\r\n\r\n\r\n\t\t// limit stage's height based on portrait_min AR\r\n\t\tconst base_h = !this.is_portrait ? h : Math.min( h, w * (1/AR.base))\r\n\t\troot.style.setProperty('--stw',w+'px')\r\n\t\troot.style.setProperty('--sth',h+'px')\r\n\t\tlet fs = Math.floor( base_h / height_rem * 10**FSD) / 10**FSD\r\n\t\troot.style.fontSize = fs + 'px'\r\n\r\n\t\tlet fs2 = Math.floor( h / height_rem * 10**FSD) / 10**FSD\r\n\t\troot.style.setProperty('--sth-based-fs', fs2 + 'px')\r\n\t\t// em to allow super-scaling (follow parent if it's scaled)\r\n\t\troot.style.setProperty('--sth-based-fs-em', fs2/fs + 'em')\r\n\r\n\t\t//log('err', 'base, h:', base_h, h)\r\n\t\t/// fs2 em should be the scale relative to normal fs?\r\n\t\t/// fs = h (1000) / height_rem (40) = 1em\r\n\r\n\t\t// log('warn', 'sth-based-fs:', h / height_rem)\r\n\r\n\t\tthis.scaling = fs / 16\r\n\t\t// root.style.setProperty('--scale', this.scaling)\r\n\t\t//log('purple', 'this.scale:', this.scale)\r\n\t\t\t// -> floor else we might overflow and get scrollbar\r\n\t\t//log('info', 'fontSize :', root.style.fontSize)\r\n\t\t// VALUE OF ONE REM IN PX (0.00)\r\n\t\t//this.REM = Math.round((base_h / height_rem) * 100) / 100\r\n\r\n\t\t// log('purple', 'resize() ->resize_watchers:', ...resize_watchers)\r\n\t\tfor( let comp of resize_watchers){ // components with onResized method\r\n\t\t\t//log('check', 'call resize for comp?, rendered? :', comp.rendered, comp)\r\n\t\t\tif( comp.rendered){\r\n\t\t\t\tcomp.onResized( AR, ASPECT_RATIOS)\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t//log('warn', 'skipped onResized', this)\r\n\t\t\t\tcomp.skipped_onResized = true\r\n\t\t\t\tcomp.skipped_params = [AR,ASPECT_RATIOS]\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// calc progress between tall AR (0) and x-tall AR (1);\r\n\t\t// can be useful to adjust something progressively from one to the other AR\r\n\t\tconst range = AR.base - AR.min // ex: 0.1,  / 0.16 = 0.83333\r\n\t\tlet xtra = null\r\n\t\tif( this.is_portrait){\r\n\t\t\t// log('check', 'AR.base - AR.now) / range:', AR.base, AR.now, range, AR.min)\r\n\t\t\txtra = (AR.base - AR.now) / range // .66 - .6 = .06 over .16\r\n\t\t\txtra = Math.max( 0, Math.min( 1, xtra))\r\n\t\t\t//log('info', '--extra (-tall progress):', xtra)\r\n\t\t}\r\n\t\tthis.style.setProperty('--extra', xtra===null ? 0 : xtra) //[0,1]\r\n\t}\r\n\r\n\tupdateAspect (ratios){\r\n\r\n\t\tif(!this.initial_ratios)\r\n\t\t\tthis.initial_ratios = ratios\r\n\r\n\t\tif( ASPECT_RATIOS)\r\n\t\t\tObject.assign( ASPECT_RATIOS, ratios)\r\n\t\telse\r\n\t\t\tASPECT_RATIOS = ratios\r\n\r\n\t\tif( ASPECT_RATIOS.portrait){\r\n\t\t\tif( !ASPECT_RATIOS.portrait_min)\r\n\t\t\t\tASPECT_RATIOS.portrait_min = .01 /// can't be 0...\r\n\t\t\tif( !ASPECT_RATIOS.portrait_max)\r\n\t\t\t\tASPECT_RATIOS.portrait_max = ASPECT_RATIOS.portrait\r\n\t\t}\r\n\r\n\t\tif( !ASPECT_RATIOS.threshold)\r\n\t\t\tASPECT_RATIOS.threshold = 1\r\n\r\n\t\tif( !ASPECT_RATIOS.cross_margin)\r\n\t\t\tASPECT_RATIOS.cross_margin = 0\r\n\r\n\t\tthis.resize()\r\n\t}\r\n\r\n\t/**\r\n\t * Build CSS to hide elements with a lang attribute not matching the app's\r\n\t *\r\n\t */\r\n\tbuildCSSForLangs (){\r\n\t\tlet str = ''\r\n\t\tfor( let lang of this.languages)\r\n\t\t\tstr += `vision-stage[lang='${lang}'] [lang]:not([lang='${lang}']) { display: none !important }\\n`\r\n\t\tconst stylesheet = document.createElement('style')\r\n\t\tstylesheet.textContent = str\r\n\t  document.head.appendChild( stylesheet)\r\n\t}\r\n\r\n\t/*buildPagesData(){\r\n\t\tthis.pages = []\r\n\t\tfor( let p of this.qAll('[page]')){\r\n\t\t\tlet name = p.getAttribute('page')\r\n\t\t\tif( name === 'any')\r\n\t\t\t\tcontinue\r\n\t\t\t// comma separated, values can contain commas but keys can't; and no space either\r\n\r\n\t\t\tlet key = p.getAttribute('page')\r\n\t\t\tlet titles = p.getAttribute('titles')\r\n\t\t\tif( !titles){\r\n\t\t\t\tthrow \"[page] elements must have [titles] attribute for langs\"\r\n\t\t\t}\r\n\t\t\telse if( !titles.includes(':')){\r\n\t\t\t\t// set the same path & title for each lang\r\n\t\t\t\tlet page_obj = {}\r\n\t\t\t\tlet path = key ? titles.replace(/\\s/g, '-') : ''\r\n\t\t\t\tfor( let lang of this.languages){\r\n\t\t\t\t\tpage_obj[ lang] = { path, title:titles }\r\n\t\t\t\t}\r\n\t\t\t\tthis.pages.push( [ key, page_obj])\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tlet strings = titles.match(/[^:,\\s]+\\:[^:]+((?=\\s*,\\s*)|$)/g)\r\n\t\t\t\tlet page_obj = {}\r\n\t\t\t\tfor( let str of strings){\r\n\t\t\t\t\tlet [lang, title] = str.split(/\\s*:\\s*REMOVETHIS/)\r\n\t\t\t\t\tlet path = key ? title.replace(/\\s/g, '-') : ''\r\n\t\t\t\t\tpage_obj[ lang] = { path, title }\r\n\t\t\t\t}\r\n\t\t\t\tthis.pages.push( [ key, page_obj])\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet str = []\r\n\t\t/// All conditions to hide an element\r\n\t\t// hide all other than show-for='none' when no page\r\n\t\tstr.push(`#app[active-page=''] [page]:not([page=''])`)\r\n\t\tstr.push(`#app[active-page=''] [show-for\\\\:page]:not([show-for\\\\:page=''])`)\r\n\r\n\t\tfor( let [page, data] of this.pages){\r\n\t\t\tif( !page) continue // home\r\n\r\n\t\t\t// hide all [page] unless it matches #app[active-page] or is 'any'\r\n\t\t\tstr.push(`#app[active-page='${page}'] [page]:not([page~='${page}']):not([page='any'])`)\r\n\t\t\tstr.push(`#app[active-page='${page}'] [show-for\\\\:page]:not([show-for\\\\:page~='${page}']):not([show-for\\\\:page='any'])`)\r\n\t\t}\r\n\t\tstr = str.join(',\\n') + '{ display: none }'\r\n\t\t// -> for transition: visibility: hidden ; opacity: 0\r\n\t\tconst stylesheet = document.createElement('style')\r\n\t\tstylesheet.classList.add('show-for-styles')\r\n\t\tstylesheet.textContent = str\r\n\t\tdocument.head.appendChild( stylesheet)\r\n\t}*/\r\n\r\n\t// must be called from the app after user event, or onConnected but then the first time it won't play on iOS\r\n\t/**\r\n\t * Basic audio playback with Web Audio. No lib! ;)\r\n\t * the main limitation is that the volume, althought it can be adjusted by individual sounds, is global, so if two sounds with different volume option||default are overlapping, the volume will sharply change; the ideal is to have sounds prerendered at the right volume. This does not concern this.global_volume which is another layer (fract. multiplier) that the user can adjust.\r\n\t * Sounds are fetched and stored: this.sounds[ name] = { audio_buffer, options }\r\n\t * @return {Promise}\r\n\t */\r\n\tsetupSounds (){\r\n\t\tlog('info', 'setupSounds')\r\n\t\tconst sounds_data = ctor( this).sounds\r\n\t\tif( !sounds_data)\r\n\t\t\treturn\r\n\r\n\t\tthis.sounds = {}\r\n\t\twindow.AudioContext = window.AudioContext || window.webkitAudioContext\r\n\t\tthis.audio_context = new window.AudioContext()\r\n\t\tthis.gain_node = this.audio_context.createGain() // global volume control\r\n\t\t// more verbose, eventually delete...\r\n\t\tif( is_iOS || is_safari){\r\n\t\t\treturn Promise.all(\r\n\t\t\t\tsounds_data.map( ([name, url, options={}]) => fetch( url)\r\n\t\t\t\t\t.then( response => response.arrayBuffer())\r\n\t\t\t\t\t.then( array_buffer => {\r\n\t\t\t\t\t\tthis.audio_context.decodeAudioData( array_buffer, audio_buffer => {\r\n\t\t\t\t\t\t\tthis.sounds[ name] = { audio_buffer, options }\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\treturn 'success'\r\n\t\t\t\t\t})\r\n\t\t\t\t)\r\n\t\t\t)\r\n\t\t}\r\n\t\telse\r\n\t\t\treturn Promise.all(\r\n\t\t\t\tsounds_data.map( ([name, url, options={}]) => fetch( url)\r\n\t\t\t\t\t.then( response => response.arrayBuffer())\r\n\t\t\t\t\t.then( array_buffer => this.audio_context.decodeAudioData( array_buffer))\r\n\t\t\t\t\t.then( audio_buffer => this.sounds[ name] = { audio_buffer, options })\r\n\t\t\t\t\t.catch( err => log('err',err))\r\n\t\t\t\t)\r\n\t\t\t)\r\n\t}\r\n\tplaySound (name){\r\n\t\tif( !this.sounds[ name]){\r\n\t\t\tlog('err', 'no sound with name:', name, 'check if sounds are set up')\r\n\t\t\treturn\r\n\t\t}\r\n\t\tconst { audio_buffer, options } = this.sounds[ name]\r\n\t\t//log('info', 'playSound:', name, options.volume)\r\n\t\tconst source = this.audio_context.createBufferSource()\r\n\t\tsource.buffer = audio_buffer\r\n\t\tthis.gain_node.gain.value = this.global_volume * (options.volume || 1)\r\n\t\tsource.connect( this.gain_node).connect( this.audio_context.destination)\r\n\t\tthis.playing_source = source\r\n\r\n\t\tif( options.delay)\r\n\t\t\tsetTimeout( e => {\r\n\t\t\t\tsource.start()\r\n\t\t\t}, options.delay)\r\n\t\telse\r\n\t\t\tsource.start()\r\n\t}\r\n\tstopSound (){\r\n\t\t//log('err', 'stop:', this.playing_source)\r\n\t\tif( this.playing_source){\r\n\t\t\tthis.playing_source.stop()\r\n\t\t\tthis.playing_source = null\r\n\t\t}\r\n\t}\r\n\r\n\t/** Get or Set; @param path string of nested prop with dot notation */\r\n\tprop (path, value){ // 'this.prop.sub-prop'\r\n\r\n\t\tlet target = this\r\n\t\tlet keys = path.split('.')\r\n\t\tlet last_key = keys.pop()\r\n\r\n\t\tfor (let k of keys)\r\n\t\t\ttarget = target[ k]\r\n\r\n\t\tif (!target){\r\n\t\t\tlog('err', 'cannot get prop', path)\r\n\t\t\treturn\r\n\t\t}\r\n\t\t// GET\r\n\t\tif (value === undefined){\r\n\t\t\tP.init( this, target, last_key, keys[0]||last_key)\r\n\t\t\treturn P\r\n\t\t}\r\n\t\t// SET\r\n\t\telse {\r\n\t\t\ttry {\r\n\t\t\t\ttarget[last_key] = value\r\n\t\t\t}\r\n\t\t\tcatch (err){\r\n\t\t\t\tlog('err', 'err:', err)\r\n\t\t\t}\r\n\t\t\tthis[keys[0]] = this[keys[0]] // trigger top-level prop\r\n\t\t\treturn this\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * (1) take an object as input,\r\n\t * (2) validate it for some conditions,\r\n\t * (3) calculate a return value from it.\r\n\t * Will render right after returning;\r\n\t * @return the result of modifier||original if validator returns true, otherwise returns null\r\n\t */\r\n\tvalueFromObject( input, validator, calc){\r\n\t\tsetTimeout( t => this.render())\r\n\t\treturn validator( input) ? calc( input) : null\r\n\t}\r\n\r\n\t/** takes a nested prop path for this (as string with dot notation),\r\n\t * and returns the object (@ before last key), the last key and the first key\r\n\t */\r\n\t// resolveProp( path){\r\n\t// \tlet obj = this\r\n\t// \tlet keys = path.split('.')\r\n\t// \tlet last_key = keys.pop()\r\n\t// \tfor( let k of keys){\r\n\t// \t\tobj = obj[ k]\r\n\t// \t}\r\n\t// \t// log('info', 'obj:', obj, last_key)\r\n\t// \treturn [obj, last_key, keys[0]]\r\n\t// }\r\n\tregisterSW(){\r\n\t\t//log('info', 'this.registerSW()')\r\n\t\tif ('serviceWorker' in navigator)\r\n\t\tnavigator.serviceWorker.register('/sw.js')\r\n\t\t\t.then( reg => {\r\n\t\t\t\tlog('info',\"Service Worker Registered\")\r\n\t\t\t\treg.onupdatefound = () => {\r\n\t\t\t\t\t//log('ok', 'SW update found')\r\n\t\t\t\t\tlet installing_worker = reg.installing\r\n\t\t\t\t\tinstalling_worker.onstatechange = async () => {\r\n\t\t\t\t\t\tlog('ok', 'SW State: ', installing_worker.state)\r\n\t\t\t\t\t\tswitch( installing_worker.state){\r\n\t\t\t\t\t\t\tcase 'installed':\r\n\t\t\t\t\t\t\t\t// WAIT FOR A POSSIBLE \"REDUNDANT\" STATE\r\n\t\t\t\t\t\t\t\t// CHROME MOBILE MAY BYPASS CACHE REFRESH ?\r\n\t\t\t\t\t\t\t\tsetTimeout( () => {\r\n\t\t\t\t\t\t\t\t\t// navigator.serviceWorker.controller is unreliable when calling update manually\r\n\t\t\t\t\t\t\t\t\tif( !active_sw && !redundant){\r\n\t\t\t\t\t\t\t\t\t\t// log('info', 'App is now available offline')\r\n\t\t\t\t\t\t\t\t\t\tthis.classList.add('cached')\r\n\t\t\t\t\t\t\t\t\t\t// this.toast.setMessage( this.$cached, ['OK', this.$install_standalone])\r\n\t\t\t\t\t\t\t\t\t\t// \t.then( answer => {\r\n\t\t\t\t\t\t\t\t\t\t// \t\tthis.toast.show = false\r\n\t\t\t\t\t\t\t\t\t\t// \t\tif( answer === 1 && this.deferredPrompt)\r\n\t\t\t\t\t\t\t\t\t\t// \t\t\tthis.install()\r\n\t\t\t\t\t\t\t\t\t\t// \t})\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t\t\t\t/// LONG RUNNING NETWORK CONNECTION (LIKE FIREBASE FIRESTORE) MAY PREVENT ACTIVATION FOR A WHILE; LOG TO KNOW\r\n\t\t\t\t\t\t\t\t\t\tlog('info', 'SW Update is available, waiting for activation')\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}, 200)\r\n\t\t\t\t\t\t\t\tbreak\r\n\r\n\t\t\t\t\t\t\tcase 'activated':\r\n\t\t\t\t\t\t\t\t/// IF NOT FIRST INSTALL, SHOW UPDATE READY: PLEASE REFRESH | LATER\r\n\t\t\t\t\t\t\t\tif( active_sw || redundant)\r\n\t\t\t\t\t\t\t\t\t// this.toast.setMessage( this.$update_ready, [this.$later, this.$refresh])\r\n\t\t\t\t\t\t\t\t\t// \t.then( answer => {\r\n\t\t\t\t\t\t\t\t\t// \t\tif( answer === 0)\r\n\t\t\t\t\t\t\t\t\t// \t\t\tthis.toast.show = false\r\n\t\t\t\t\t\t\t\t\t// \t\telse\r\n\t\t\t\t\t\t\t\t\t// \t\t\tlocation.reload()\r\n\t\t\t\t\t\t\t\t\t// \t})\r\n\t\t\t\t\t\t\t\tbreak\r\n\r\n\t\t\t\t\t\t\tcase 'redundant':\r\n\t\t\t\t\t\t\t\tredundant = true\r\n\t\t\t\t\t\t\t\tbreak\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/// CHECK FOR UPDATE ONCE IN A WHILE TO NOTIFY A USER USING THE APP FOR A LONG TIME\r\n\t\t\t\t/// (OR WHO KEEP THE TAB OPEN, NEVER REFRESHING)\r\n\t\t\t\tsetInterval( () => {\r\n\t\t\t\t\tlog('ok', 'checking for service worker update...')\r\n\t\t\t\t\treg.update()\r\n\t\t\t\t}, 1000 * 60 * UPDATE_CHECK_MIN)\r\n\t\t\t})\r\n\t\t// else if( is_IOS)\r\n\t\t// \talert ('Offline service unsupported    Apple wants you to use Safari, for your own good! ')\r\n\t}\r\n}\r\n\r\n// these static properties are underscore prefixed\r\n// so they are merged instead of overriden next by > MyApp.properties\r\n\r\nVisionStage._properties = {\r\n\ttitle: '',\r\n\tresizing: {\r\n\t\tvalue: false,\r\n\t\tclass: 'resizing',\r\n\t\treactive: false\r\n\t},\r\n\tglobal_volume: {\r\n\t\tvalue: .6,\r\n\t\tstorable: true,\r\n\t\treactive: false\r\n\t},\r\n\tlang: {\r\n\t\tvalue: navigator.language.slice(0,2),\r\n\t\tstorable: true,\r\n\t\tforce_render: true,\r\n\t\twatcher( val, prev){\r\n\t\t\t//log('pink', 'lang:', val)\r\n\t\t\t// set complete lang code on <html> for speak function\r\n\t\t\tlet [lang, country] = navigator.language.split('-')\r\n\t\t\tdocument.documentElement.setAttribute('lang', val)// + '-' + country)\r\n\t\t\tthis.country = country\r\n\t\t\t// set val (2 letter) on this element for CSS auto hide of els w/ [lang] not matching\r\n\t\t\tthis.setAttribute('lang', val)\r\n\t\t\tthis.lang_index = this.languages.indexOf( val)\r\n\t\t\tthis.onLanguageChanged && this.onLanguageChanged( val, prev)\r\n\t\t\t// log('err', 'this.lang_index:', this.lang_index)\r\n\t\t\t// update hash and doc title\r\n\r\n\t\t\tif( this.pages && this.page){\r\n\t\t\t\t/// update hash / page title for current lang\r\n\t\t\t\tlet {path, title} = this.getPage()\r\n\t\t\t\tlocation.hash = path\r\n\t\t\t\tif( this.$doc_title)\r\n\t\t\t\t\tdocument.title = this.$doc_title + '  ' + title // decodeURI( location.hash.slice(1))\r\n\t\t\t}\r\n\t\t\tlog('info', 'lang, country:', lang, country)\r\n\t\t},\r\n\t\t//init_watcher: true // causes render (SET lang), maybe too soon, keep manual\r\n\t\t// -> instead just re-trigger after this is rendered (lang = lang)\r\n\t},\r\n\tnight_mode: {\r\n\t\tvalue: 0,\r\n\t\tstorable: true,\r\n\t\tattribute: ['night-mode', 'auto'], // auto -> remove if falsy, otherwise use value\r\n\t\tinit_watcher: true,\r\n\t\twatcher( val){\r\n\t\t\tdocument.body.classList.toggle('night-mode-1', val===1)\r\n\t\t\tdocument.body.classList.toggle('night-mode-2', val===2)\r\n\t\t\t//this.classList.toggle('has-dark-bg', !!val)\r\n\t\t\t//this.switchClasses('has-bright-bg', 'has-dark-bg', val==='whitish')\r\n\t\t}\r\n\t},\r\n\tmenu_open: { value: false, class: 'menu-open'},\r\n\r\n\t// bool props defining CSS classes when true\r\n\t// faded: {\r\n\t// \tvalue: true,\r\n\t// \tclass: 'faded',\r\n\t// \treactive: false\r\n\t// },\r\n\tpage: {\r\n\t\tvalue: null,\r\n\t\tattribute: 'page',\r\n\t\twatcher( val, prev){\r\n\t\t\t// remove trailing #\r\n\t\t\tif( !val && location.href.endsWith('#') && window.self === window.top)\r\n\t\t\t\thistory.replaceState( null, '', location.pathname)\r\n\r\n\t\t\tthis.onPageChanged && this.onPageChanged( val, prev)\r\n\t\t}\r\n\t},\r\n}\r\n\r\nVisionStage._strings = {\r\n\tfullscreen: [\"Fullscreen\", \"Plein cran\"],\r\n\tnight_mode: [\"Night Mode\", \"Mode nuit\"],\r\n}\r\n\r\n/**\r\n * Helper object which is setup and returned by this.prop()\r\n * Gives methods to operate on array and object props and render the target.\r\n */\r\nexport const P = {\r\n\r\n\tinit (target, prop_object, prop_name, parent_prop_name){\r\n\t\t//log('ok', 'init prop:', this.parent_prop_name)\r\n\t\tthis.target = target\r\n\t\tthis.prop_object = prop_object\r\n\t\tthis.prop_name = prop_name\r\n\t\tthis.parent_prop_name = parent_prop_name\r\n\t\tthis.prop = this.prop_object[ this.prop_name]\r\n\t\t//log('err', 'prop obj:', this.prop_object, prop_name)\r\n\t\t//debugger\r\n\t},\r\n\t/** triggers transformer/watcher/render by re-setting the top prop */\r\n\tresetTarget(){\r\n\t\t// log('check', 'reset target:', this.parent_prop_name, this.prop_name)\r\n\t\tthis.target[ this.parent_prop_name] = this.target[ this.parent_prop_name]\r\n\t\treturn this\r\n\t},\r\n\r\n\t// -> this.prop('todo', this.prop('todos').push( this.newTodo( val)))\r\n\r\n\t/** @return the new value */\r\n\tpush (value){\r\n\t\tthis.prop.push( value)\r\n\t\tthis.resetTarget()\r\n\t\treturn value\r\n\t},\r\n\t/** @return the new value */\r\n\tpushStart (value){\r\n\t\tthis.prop.unshift( value)\r\n\t\tthis.resetTarget()\r\n\t\treturn value\r\n\t},\r\n\tpop(){\r\n\t\tsetTimeout( t => this.resetTarget())\r\n\t\treturn this.prop.pop()\r\n\t},\r\n\tpopStart(){\r\n\t\tsetTimeout( t => this.resetTarget())\r\n\t\treturn this.prop.shift()\r\n\t},\r\n\tsplice (index, delete_count=1, ...inserts){\r\n\t\tthis.prop.splice( index, delete_count, ...inserts)\r\n\t\tthis.resetTarget()\r\n\t},\r\n\tremove (index){ this.splice( index) },\r\n\tinsert (index, ...values){ this.splice( index, 0, ...values) },\r\n\r\n\t/** flips a nested prop value and re-set: this.prop('options.xmode').flip() */\r\n\tflip(){\r\n\t\tthis.prop_object[ this.prop_name] = !this.prop_object[ this.prop_name]\r\n\t\tthis.resetTarget()\r\n\t},\r\n\r\n\t/** select an item or unselect it if already set, as the value for a prop */\r\n\ttoggleSelect (item){\r\n\t\t//! what if nested prop?\r\n\t\t// this.prop = this.prop===item ? null : item\r\n\t\tthis.prop_object[ this.prop_name] = this.prop===item ? null : item\r\n\t\tthis.resetTarget()\r\n\t},\r\n\t// -> this.prop('todo').toggleSelect( todo) // instead of\r\n\t// \tthis.todo = this.todo===todo ? null : todo ; this.render()\r\n\r\n\t/** find a [name,value] pair by name for the selected prop\r\n     * and return the value only, unless we want the whole pair */\r\n\tget (name, return_value_only=true){\r\n\t\tlog('check', 'get:', name, 'this.prop:', this.prop)\r\n\t\tlet found = this.prop.find( ([n,v]) => n===name)\r\n\t\treturn return_value_only ? (found||[])[1] : found\r\n\t},\r\n\tset (name, value){ // pair is created if not found\r\n\t\tlet pair = this.get( name, false)\r\n\t\tif( pair)\r\n\t\t\tpair[1] = value\r\n\t\telse\r\n\t\t\tthis.prop.push( [name, value])\r\n\t\tthis.resetTarget()\r\n\t},\r\n\r\n\t// cycle\r\n\tnextIn (values, steps=1, wrap=true){\r\n\t\tlet start = values.indexOf( this.prop)\r\n\t\tlet next = (values.length + start + steps)\r\n\t\tif( wrap) next = next % values.length\r\n\t\telse next = clamp( next, 0, values.length-1)\r\n\t\treturn this.prop_object[ this.prop_name] = values[ next]\r\n\t},\r\n}\r\n\r\n\r\n// shorthand version of\r\n// this.prop( prop).toggleSelect( item)\r\n// instead import this and bind it, then use like:\r\n// togSel('prop', item)\r\n// export function toggleSelect(prop,item){ this.prop(prop).toggleSelect(item) }\r\n\r\nlet DIRECTORY = ''\r\n/**\r\n * Defines a custom element (window.customElements.define) and return whenDefined promise\r\n * @param components wait and load required components before define\r\n * @return whenDefined's promise\r\n * @usage `define('my-comp', MyCompClass, []).then( ...)`\r\n */\r\nexport async function define( tag_name, clss, components, directory=''){\r\n\tif( directory)\r\n\t\tDIRECTORY = directory\r\n\t// import comps (js & css) dependencies (when required right from the start)\r\n\tif( components && components.length){ // app is not defined yet\r\n\t\tcomponents = components.map( c => Component.load( c))\r\n\t\tawait Promise.all( components)\r\n\t}\r\n\r\n\twindow.customElements.define( tag_name, clss)\r\n\r\n\treturn window.customElements.whenDefined( tag_name).then( () => {\r\n\t\t//log('check', 'when defined:', tag_name)\r\n\t\tif( tag_name === 'vision-stage'){\r\n\r\n\t\t\tapp.resize()\r\n\t\t\tapp.classList.add('resized')\r\n\r\n\t\t\tsetTimeout( e => {\r\n\t\t\t\twindow.addEventListener('resize', debounce( app.resize.bind( app), 300, 300)),\r\n\t\t\t\t2000\r\n\t\t\t})\r\n\t\t\t// ->  Arg 1: debounce dly (wont callback until you stop calling and after a delay),\r\n\t\t\t// ->  Arg 2: throttle dly (wont callback more often than at this frequency)\r\n\t\t}\r\n\t})\r\n}\r\n\r\n/**\t=> html`<svg><use src='#'>...</svg>` */\r\nexport function useSVG( id, clss, ar){\r\n\tlet src = app.icons_path || DIRECTORY + '/_assets/images/icons.svg'\r\n\t// proxy names\r\n\tif( icons_mappings[id])\r\n\t\tid = icons_mappings[id]\r\n\tlet vb = icons_mappings_vb[id] || '0 0 32 32'\r\n\r\n\treturn html`<svg class=${clss ? 'icon '+clss : 'icon'} viewBox=${vb} preserveAspectRatio=${ ifDefined( ar) }>\r\n\t\t<use href='${src}#${id}'/>\r\n\t</svg>`\r\n}\r\n/** wraps useSVG symbol inside a span.vs-icon */\r\nexport function icon( svg_id, clss='', opts={}){\r\n\treturn html`<span class='vs-icon ${clss}'>${ useSVG( svg_id, opts.svg_class||'', opts.ar) }</span>`\r\n}\r\n\r\nexport function maybe( thing){\r\n\treturn thing || {}\r\n}\r\n/** [ option (label || [label,value]) ] */\r\nexport function Options( opts){\r\n\tconst details = []\r\n\tconst labels = opts.map( o => Array.isArray(o) ? o[0] : o)\r\n\t\t// labels might have details ( \"label | more details...\" )\r\n\t\t.map( (label,i) => typeof label === 'string' ?\r\n\t\t\tparseLabel( label, details, i) :\r\n\t\t\tparseLabels( label, details, i))\r\n\t// Copy label for value:\r\n\t// option not array / is string -> take it for value\r\n\t// option is array : // [[label_en, label_fr], v?]\r\n\t// if value ([1]), take it\r\n\t// else, [0] is labels, take first label [0], default lang\r\n\t// (if no val and single label, option would not be an array...)\r\n\t/// if we copy label b/c no value, use the parsed one from above...\r\n\tconst values = opts.map( (o,i) => Array.isArray(o) ? o[1]!==undefined ? o[1] :\r\n\t\tparseLabel(o[0][0]) : labels[i])\r\n\t//log('info', 'labels, values',labels, values)\r\n\treturn { labels, values, details, classes: opts.map( o => o[2]) }\r\n}\r\nfunction parseLabel( label, details, index){\r\n\tlet [l,d] = label.split(' | ')\r\n\tif( details) details[ index] = d\r\n\treturn l\r\n}\r\nfunction parseLabels( labels, details, index){\r\n\tlet [l,d] = explodeArray( labels.map( str => str.split(' | ')))\r\n\tdetails[ index] = d\r\n\treturn l // arrays of only locale labels\r\n}\r\n\r\nconst explodeArray = (arr) => arr.reduce( (cumul,val) =>\r\n\tcumul.forEach((a,i) => a.push( val[ i])) || cumul\r\n, Array.from( Array(arr[0].length), () => []) )\r\n\r\nexport const classes = (...classes) => classes.filter( c => c).join(' ')\r\nexport const labelAsClassMapper = o =>\r\n\ttypeof o === 'string' ? {label:o, class:o} : {...o, class:o.label}\r\n\r\nexport const createOptions = opts => ({\r\n\tlabels: opts.map( o =>\r\n\t\ttypeof o === 'string' ? o :\r\n\t\to.label !== undefined ? o.label :\r\n\t\topts[0].label), // default to first option's label (required, unless .icon prop)\r\n\tdetails: opts.map( o => o.detail),\r\n\tvalues: opts.map( o =>\r\n\t\to.value !== undefined ? o.value :\r\n\t\tArray.isArray(o.label) ? o.label[0] : o.label||o\r\n\t),\r\n\tclasses: opts.map( o => o.class !== undefined ? o.class :\r\n\t\t!o.label ? opts[0].class : undefined),\r\n\tselected_class: opts.map( o =>\r\n\t\to.selected_class !== undefined ? o.selected_class :\r\n\t\to.label === undefined ? opts[0].selected_class : undefined\r\n\t),\r\n\ticons: opts.map( o => o.icon)\r\n})\r\n///  STORE  ///\r\n\r\n/** Parse store from localStorge or init a new one */\r\nfunction initStore( ns){\r\n\t//log('check', 'init store:', ns)\r\n\tstore_namespace = ns\r\n\tif( !ns){\r\n\t\tlog('err', 'no store namespace');\r\n\t\treturn\r\n\t}\r\n\r\n\tif( CLEAR_STORE){\r\n\t\tlog('err','--CLEAR_STORE')\r\n\t\tstore = {}\r\n\t\tlocalStorage.setItem( store_namespace, \"{}\")\r\n\t\treturn\r\n\t}\r\n\r\n\tlet stored_data = localStorage.getItem( ns)\r\n\tlog('ok','RAW:', stored_data)\r\n\tif( stored_data){\r\n\t\ttry { store = JSON.parse( stored_data); }\r\n\t\tcatch( err){\r\n\t\t\tlog('err','JSON parse error')\r\n\t\t\tlog('warn', 'stored_data:', stored_data)\r\n\t\t}\r\n\t}\r\n\r\n\tif( ! store || ! isObject( store)){\r\n\t\tif( debug.store) log('notok', 'NO STORE, CREATING ONE')\r\n\t\tstore = {}\r\n\t}\r\n\telse if( debug.store) {\r\n\t\tlog('ok', 'GOT store:')\r\n\t\t//log(JSON.stringify(store,null,2))\r\n\t\tlog( store)\r\n\t}\r\n}\r\n/** Get a possibly stored value || undefined */\r\nfunction storedValue( elem_id, prop){\r\n\tlet s = store[ elem_id]\r\n\t//if( debug.store)\r\n\t//log('purple', 'get stored:', s, 'elem_id:', elem_id)\r\n\treturn s ? s[ prop] : undefined\r\n}\r\n/** either save after setting a prop on elem, or just save */\r\nexport function saveStore( elem_id, prop, val, remove=false){\r\n\r\n\tif( app && app.do_not_store) return\r\n\r\n\t//! was async: problem if used on unload event... cannot block\r\n\t//!  => should make async + another sync version for unload\r\n\r\n\tif( !store) return null //|| CLEAR_STORE\r\n\r\n\t//log('err', '--save to store, elem id:', elem_id)\r\n\r\n\tif( elem_id){ //// WE WANT TO SET A STORE VALUE BEFORE SAVING\r\n\r\n\t\tif( remove){\r\n\t\t\tlog('err', 'DELETE:', elem_id, prop)\r\n\t\t\tif( store[ elem_id]){\r\n\t\t\t\tdelete store[ elem_id][ prop]\r\n\t\t\t\t/// if this elem has no more stored props, delete its store\r\n\t\t\t\tif( ! Object.keys( store[ elem_id]).length)\r\n\t\t\t\t\tdelete store[ elem_id]\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\t//if( debug.store)\r\n\t\t\tlog('pink', 'STORING:', elem_id, prop, val)\r\n\t\t\tif( store[ elem_id] === undefined)\r\n\t\t\t\tstore[ elem_id] = {}\r\n\t\t\tstore[ elem_id][ prop] = val\r\n\t\t}\r\n\t}\r\n\r\n\t// if( !willSave){ //// BATCH CALLS\r\n\t// willSave = true\r\n\t// await 0;\r\n\t// willSave = false\r\n\tconst str = JSON.stringify( store)\r\n\tif( debug.store){\r\n\t\tlog('pink', '--will store string:', str)\r\n\t}\r\n\tlocalStorage.setItem( store_namespace, str)\r\n}\r\nexport function clearStore( e){\r\n\tlog('err', 'clear store')\r\n\tapp.do_not_store = true // prevent storing on before reload\r\n\tlocalStorage.removeItem( store_namespace)\r\n\tlog('err', 'Store cleared')\r\n\tlocation.reload()\r\n}\r\n//  Setting many props at once with storable:true, each will call saveStore (writes to LS),\r\n//  so use a throttled \"version\" instead\r\nconst throttled_saveStore = debounce( saveStore, 200)\r\n\r\n// screenfull.min.js\r\n!function(){\"use strict\";var e=window.document,n=function(){for(var n,r=[[\"requestFullscreen\",\"exitFullscreen\",\"fullscreenElement\",\"fullscreenEnabled\",\"fullscreenchange\",\"fullscreenerror\"],[\"webkitRequestFullscreen\",\"webkitExitFullscreen\",\"webkitFullscreenElement\",\"webkitFullscreenEnabled\",\"webkitfullscreenchange\",\"webkitfullscreenerror\"],[\"webkitRequestFullScreen\",\"webkitCancelFullScreen\",\"webkitCurrentFullScreenElement\",\"webkitCancelFullScreen\",\"webkitfullscreenchange\",\"webkitfullscreenerror\"],[\"mozRequestFullScreen\",\"mozCancelFullScreen\",\"mozFullScreenElement\",\"mozFullScreenEnabled\",\"mozfullscreenchange\",\"mozfullscreenerror\"],[\"msRequestFullscreen\",\"msExitFullscreen\",\"msFullscreenElement\",\"msFullscreenEnabled\",\"MSFullscreenChange\",\"MSFullscreenError\"]],l=0,t=r.length,c={};l<t;l++)if((n=r[l])&&n[1]in e){for(l=0;l<n.length;l++)c[r[0][l]]=n[l];return c}return!1}(),r={change:n.fullscreenchange,error:n.fullscreenerror},l={request:function(r,l){return new Promise(function(t,c){var u=function(){this.off(\"change\",u),t()}.bind(this);this.on(\"change\",u);var s=(r=r||e.documentElement)[n.requestFullscreen](l);s instanceof Promise&&s.then(u).catch(c)}.bind(this))},exit:function(){return new Promise(function(r,l){if(this.isFullscreen){var t=function(){this.off(\"change\",t),r()}.bind(this);this.on(\"change\",t);var c=e[n.exitFullscreen]();c instanceof Promise&&c.then(t).catch(l)}else r()}.bind(this))},toggle:function(e,n){return this.isFullscreen?this.exit():this.request(e,n)},onchange:function(e){this.on(\"change\",e)},onerror:function(e){this.on(\"error\",e)},on:function(n,l){var t=r[n];t&&e.addEventListener(t,l,!1)},off:function(n,l){var t=r[n];t&&e.removeEventListener(t,l,!1)},raw:n};n?(Object.defineProperties(l,{isFullscreen:{get:function(){return Boolean(e[n.fullscreenElement])}},element:{enumerable:!0,get:function(){return e[n.fullscreenElement]}},isEnabled:{enumerable:!0,get:function(){return Boolean(e[n.fullscreenEnabled])}}}),window.screenfull=l):window.screenfull={isEnabled:!1}}();\r\n\r\n// if needed, should be a member of app\r\n// export const px2rem = (px, decimals=FONT_SIZE_DECIMALS) => {\r\n// \treturn app && px/app.REM || 0 // ex: px=100, app.REM=16 = 100/16 = 6.25rem\r\n// }\r\n\r\n/*\r\n\t\tCTOR:\r\n\r\n\t\t// this.getActiveSW().then( SW => {\r\n\t\t// \tactive_sw = SW || null\r\n\t\t// })\r\n\r\n\t\t// let icons_path = this.getAttribute('icons')\r\n\t\t// if( icons_path)\r\n\t\t// \tthis.icons_path = icons_path\r\n\r\n\r\n\t\tthis._onInstallable = this.onInstallable.bind( this)\r\n\t\tthis._onClickInstall = this.onClickInstall.bind( this)\r\n\t\twindow.addEventListener('beforeinstallprompt', this._onInstallable)\r\n */"],"names":["directives","WeakMap","directive","f","args","d","set","isDirective","o","has","isCEPolyfill","window","customElements","undefined","polyfillWrapFlushCallback","reparentNodes","container","start","end","before","n","nextSibling","insertBefore","removeNodes","removeChild","noChange","nothing","marker","String","Math","random","slice","nodeMarker","markerRegex","RegExp","boundAttributeSuffix","Template","constructor","result","element","this","parts","nodesToRemove","stack","walker","document","createTreeWalker","content","lastPartIndex","index","partIndex","strings","values","length","node","nextNode","nodeType","hasAttributes","attributes","count","i","endsWith","name","stringForPart","lastAttributeNameRegex","exec","attributeLookupName","toLowerCase","attributeValue","getAttribute","removeAttribute","statics","split","push","type","tagName","currentNode","data","indexOf","parent","parentNode","lastIndex","insert","s","createMarker","match","createTextNode","previousSibling","pop","str","suffix","isTemplatePartActive","part","createComment","TemplateInstance","template","processor","options","__parts","update","setValue","commit","_clone","fragment","cloneNode","importNode","nodeIndex","nodeName","handleTextExpression","insertAfterNode","handleAttributeExpressions","adoptNode","upgrade","policy","trustedTypes","createPolicy","createHTML","commentMarker","TemplateResult","getHTML","l","html","isCommentBinding","commentOpen","lastIndexOf","attributeMatch","substr","getTemplateElement","createElement","value","innerHTML","SVGTemplateResult","super","svgElement","firstChild","isPrimitive","isIterable","Array","isArray","Symbol","iterator","AttributeCommitter","dirty","_createPart","AttributePart","_getValue","v","text","t","setAttribute","committer","NodePart","__pendingValue","appendInto","startNode","appendChild","endNode","ref","appendIntoPart","__insert","insertAfterPart","__commitText","__commitTemplateResult","Node","__commitNode","__commitIterable","clear","valueAsString","templateFactory","instance","itemParts","itemPart","item","BooleanAttributePart","Error","PropertyCommitter","single","PropertyPart","eventOptionsSupported","capture","addEventListener","removeEventListener","_e","EventPart","eventName","eventContext","__boundHandleEvent","e","handleEvent","newListener","oldListener","shouldRemoveListener","once","passive","shouldAddListener","__options","getOptions","event","call","defaultTemplateProcessor","prefix","templateCache","templateCaches","get","stringsArray","keyString","Map","key","join","svg","previousValues","unsafeHTML","previousValue","ifDefined","createAndInsertPart","containerPart","beforePart","beforeNode","newPart","updatePart","insertPartBefore","removePart","generateMap","list","map","partListCache","keyListCache","repeat","items","keyFnOrTemplate","keyFn","oldParts","oldKeys","newParts","newValues","newKeys","newKeyToIndexMap","oldKeyToIndexMap","oldHead","oldTail","newHead","newTail","oldIndex","oldPart","live","checkStrings","hasAttribute","guard","every","from","cache","cachedTemplate","nodes","createDocumentFragment","is_mac","navigator","platform","is_iOS","test","maxTouchPoints","is_safari","userAgent","strIf","condition","ctor","target","Object","getPrototypeOf","cleanNum","num","places","parseFloat","toFixed","isObject","debounce","callback","debounce_dly","throttle_dly","initial_call","precision","_params","elapsed","t3","last_callback","now","last_call","onInterval_running","initially_called","params","Date","setInterval","onInterval","clearInterval","COMPONENTS_DIR","log","debug","app","store","store_namespace","after_resize_timeout","ASPECT_RATIOS","resize_watchers","Set","icons_mappings","delete","remove","add","x","icons_mappings_vb","fanion","loaded_components","Component","HTMLElement","localName","id","languages","path","decodeURI","location","pathname","app_name","ns","replace","stored_data","localStorage","getItem","JSON","parse","err","initStore","buildCSSForLangs","init","uses","connectedCallback","onConnected","_ctor","properties","is_component","_state","_properties","assign","flat_properties","entries","prop","desc","storable","store_id","stored_val","storedValue","use_value","saveStore","class","classList","toggle","attribute","requestAnimationFrame","attr","defineProperty","getter","val","t_val","no_render","prev_val","transformer","bypass_transformer","force_render","throttled_saveStore","block_watcher","watcher","reactive","render","renders","render_target","init_watcher","setOnRendered","setTimeout","obj","stringify","_strings","getString","onResized","sounds","sounds_list","entry","prop_holder","props","className","prop_holder_selector","sel","querySelector","setState","setAttr","async","evt_ctx","debugging","includes","needsRender","Promise","resolve","rendered","beforeFirstRender","beforeRender","tmpl","litRender","scopeName","event_context","has_been_rendered","_onFirstRendered","onFirstRendered","skipped_onResized","skipped_params","_onRendered","onRendered","q","qAll","querySelectorAll","str_name","raw","lang","lang_index","containsHTMLElements","containsHTMLEntities","containsHTML","startsWith","switchClasses","a","b","getAttributeList","alt","getStringList","static","file_path","scripts","load","js","css","href","DIRECTORY","reject","onerror","console","error","onload","rel","head","import","components","c","all","redundant","VisionStage","scrolls","contains","termination_event","self","foldable_components","body","closest","sel_btn","folded","onHashChanged","bind","updateAspect","aspects","_onInstallable","onInstallable","_onInstalled","onInstalled","preventDefault","deferredPrompt","install","prompt","$doc_title","title","hash","setupSounds","setPageFromHash","h","page","p","k","isNaN","page_name","outer","pages","getPage","p_name","find","pageLink","postfix","clss","pre","titles","afterResize","resizing","updateScrollbarClass","main","scrollHeight","offsetHeight","resize","resize_locked","clearTimeout","threshold","root","documentElement","FSD","font_size_decimals","w","innerWidth","innerHeight","AR","min","is_portrait","portrait","landscape","height_rem","portrait_height","height","landscape_height","portrait_min","base","max","portrait_max","tall","landscape_max","wide","margin","above_landscape_max","below_landscape","cm","cross_margin","ar","asp","floor","MIN_AR","sth","stw","base_h","style","setProperty","fs","fontSize","fs2","scaling","comp","range","xtra","ratios","initial_ratios","stylesheet","textContent","sounds_data","AudioContext","webkitAudioContext","audio_context","gain_node","createGain","url","fetch","then","response","arrayBuffer","array_buffer","decodeAudioData","audio_buffer","catch","playSound","source","createBufferSource","buffer","gain","global_volume","volume","connect","destination","playing_source","delay","stopSound","stop","keys","last_key","P","valueFromObject","input","validator","calc","registerSW","serviceWorker","register","reg","onupdatefound","installing_worker","installing","onstatechange","state","language","prev","country","onLanguageChanged","night_mode","menu_open","top","history","replaceState","onPageChanged","fullscreen","prop_object","prop_name","parent_prop_name","resetTarget","pushStart","unshift","popStart","shift","splice","delete_count","inserts","flip","toggleSelect","return_value_only","found","pair","nextIn","steps","wrap","next","define","tag_name","directory","whenDefined","useSVG","src","icons_path","icon","svg_id","opts","svg_class","maybe","thing","Options","details","labels","label","parseLabel","explodeArray","parseLabels","classes","arr","reduce","cumul","forEach","filter","labelAsClassMapper","createOptions","detail","selected_class","icons","elem_id","do_not_store","setItem","clearStore","removeItem","reload","r","change","fullscreenchange","fullscreenerror","request","u","off","on","requestFullscreen","exit","isFullscreen","exitFullscreen","onchange","defineProperties","Boolean","fullscreenElement","enumerable","isEnabled","fullscreenEnabled","screenfull"],"mappings":"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"}